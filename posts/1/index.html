<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Writing an Overlayed DTS | Saalim Quadri</title><meta name=keywords content><meta name=description content="Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation. Learn how to create them!

Basics
A device tree is a data structure for describing hardware.
Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation."><meta name=author content="squadri"><link rel=canonical href=https://danascape.github.io/posts/1/><link crossorigin=anonymous href=/assets/css/stylesheet.ecb14332dfba04052a266caa0f33168daa8dd2df45fe49adcb98d99df3cb40f6.css integrity="sha256-7LFDMt+6BAUqJmyqDzMWjaqN0t9F/kmty5jZnfPLQPY=" rel="preload stylesheet" as=style><link rel=icon href=https://danascape.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://danascape.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://danascape.github.io/favicon.ico><link rel=apple-touch-icon href=https://danascape.github.io/favicon.ico><link rel=mask-icon href=https://danascape.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://danascape.github.io/posts/1/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WDDV94BTDD"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WDDV94BTDD")}</script><meta property="og:url" content="https://danascape.github.io/posts/1/"><meta property="og:site_name" content="Saalim Quadri"><meta property="og:title" content="Writing an Overlayed DTS"><meta property="og:description" content="Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation. Learn how to create them!
Basics A device tree is a data structure for describing hardware.
Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-21T00:00:00+05:30"><meta property="article:modified_time" content="2021-09-21T00:00:00+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Writing an Overlayed DTS"><meta name=twitter:description content="Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation. Learn how to create them!

Basics
A device tree is a data structure for describing hardware.
Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://danascape.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Writing an Overlayed DTS","item":"https://danascape.github.io/posts/1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Writing an Overlayed DTS","name":"Writing an Overlayed DTS","description":"Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation. Learn how to create them!\nBasics A device tree is a data structure for describing hardware.\nOverlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation.\n","keywords":[],"articleBody":"Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation. Learn how to create them!\nBasics A device tree is a data structure for describing hardware.\nOverlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation.\nThis will involve modifying OEM device trees from their import commit to a fully overlayed device tree; as an example, from this to this.\nSteps 1. Find the initial device tree import for your device For example, in my case on the device Asus X01AD (sdm632), they were added in this commit.\nAs you can see, most changes are additions done by the OEM.\nNow, grab a dmesg from the stock kernel, and find the name of the DTB that your stock kernel uses. We will need it to create our initial base device tree.\nYou will find something like this in your dmesg (start the dmesg from 0’th second).\nMachine: Qualcomm Technologies, Inc. SDM632 PMI632 QRD SKU3\nwhich implies our bootloader loads the dtb which points out to SDM632 PMI632 QRD SKU3 Board Name.\n2. Make a clean base of your kernel which just boots For a clean kernel base, we add only the required changes on top of a base CAF (Code Aurora Forum) or ALS (Android Linux Stable) kernel source, which is enough to boot our device.\nThis minimal change-set differs from device to device, some devices might just boot on dts (device tree structure) imports but some devices might need additional changes in power or video drivers, and hence we must add all these as per requirement.\nBefore proceeding to write overlayed dts, I will consider that you have succeeded in booting your devices over a clean CAF or ALS base with minimal changes.\nAs an example, my Asus X01AD took quite a few changes to boot; you can look into it here.\n3. Get to know the device tree Now stalk (well, research or learn about) your dtsi imports so that you can know what the OEM changed over the base source – the additions and deletions, addition of new panels and battery data, and so on.\n4. Create your DTS file Every device boots only on a single DTSI which points to the correct board name. In my case, it pointed to SDM632 PMI632 QRD SKU3 as we saw in point 1, and I found model = \"Qualcomm Technologies, Inc. SDM632 + PMI632 SOC\"; in sdm632.dts.\nAs per my convenience, I named it sdm632-X01AD.dts – you can choose whatever name you want. This will be the DTS which includes other overlayed DTS.\n5. Make our kernel build our new DTS You need to include the DTS in the Makefile of the dts directory – arch/arm64/boot/dts/qcom/Makefile, under the correct architecture name, ARCH_SDM632 in this case.\nYou can call our DTS by inserting your dtsname.dtb under architecture, as seen in this commit. This is a bit different because I added guards in the Makefile to make sure only one DTB for my device is built, since it takes up space for no reason if the ones not needed are built too.\n6. Organising the DTS You can now create a directory to organise the various DTS files if you want to (I called it X01AD). You can also create sub-directories if you want, mainly to divide display panel DTS or the battery data DTS and so on, this is all upto you.\n7. Identifying the DSI panel and battery data DTSIs This step is for those who cannot recognise which dtsi are for DSI (Device Serial Interface) panels or battery data.\nTo find them, you can check names of DTSIs in your OEM import. This works in most cases. Display panel DTSI will look like dsi-panel-\"name-of-driver\"-\"resolution\"-video.dtsi.\nBattery data DTSIs are different as per devices, so we will find them accordingly.\nIn my case, I found dsi-panel-ili9881h-720p-video.dtsi for display and Huaqin_QL1830scud_4000mAh_averaged_MasterSlave_Sept25th2018_PMI632.dtsi for battery data.\n8. Creating the base DTSI You now need to create a base DTSI in your custom directory and include it at the end of the .dts file we created in point 4.\nYou can include it as #include \"your-custom-directory/base.dtsi\".\nMy base dtsi is X01AD-base.dtsi and is included in this commit.\nNote that the base dtsi is created to bind up includes in a directory – it’s upto you if you want to include other DTSIs from your base DTS or use my way, they’re both fine.\n9. Verifying our DTB builds You can try to build your kernel and check if it goes fine. You can skip this step if you’re confident about your work, it’s just to confirm if our includes are correct.\nIn my case, I found my DTB built in out/arch/arm64/boot/dts.\nNow – this might be discouraging, but we’ve just begun; up until now, we haven’t finished 10% of the work. Battery data and DSI panel changes are just additions, so that’s the easiest part.\n10. Checking out the changes in DTSI import commit For example, let’s take msm8953.dtsi as per this commit.\nCreate a similar DTSI in your desired overlayed directory. This will make it easy for you and others to recall. In my case, it was X01AD-msm8953.dtsi.\nNow include this in your base overlay DTS or DTSI that you created in your device directory.\n11. Bringing in changes Check the syntax in your OEM DTSI.\nIn my case, the DTSI starts with / {.\nDTSIs can start with braces (as you saw above) or nodes – \u0026node.\nNow, let’s have a look at another example.\nIn this line, the address of the other_ext region has been changed.\nIn order to write that in our overlayed DTSI, write a new dtsi with / {, and follow up till that address, the other_ext_region.\nThere’s no need to include other regions, adresses, or nodes, since our OEM has not modified them, leaving them as-is to be included from the base DTSI.\nThis is an important step, since if it goes wrong, you will end up with weird cryptic errors from dtc. Our purpose can be to add, remove, or overwrite nodes, or to change regions, or add or remove properties.\nIf you understood the above your dtsi should look as such:\n/ { reserved-memory { other_ext_mem: other_ext_region@0 { It’s now time to write our updated property:\nreg = \u003c0x0 0x84a00000 0x0 0x1e00000\u003e;\nAnd now we just close the curly braces as per the syntax:\n/ { reserved-memory { other_ext_mem: other_ext_region@0 { reg = \u003c0x0 0x84a00000 0x0 0x1e00000\u003e; }; }; }; There you go – you just made the same OEM changes overlayed in a new DTSI which will now be overridden onto the base DTSI during compilation.\nOther changes will also involve the same process, and you might need to delete nodes or properties as such:\n/delete-property/ property-name;\n/delete-node/ node-name;\nHere’s an example.\n","wordCount":"1164","inLanguage":"en","datePublished":"2021-09-21T00:00:00+05:30","dateModified":"2021-09-21T00:00:00+05:30","author":{"@type":"Person","name":"squadri"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://danascape.github.io/posts/1/"},"publisher":{"@type":"Organization","name":"Saalim Quadri","logo":{"@type":"ImageObject","url":"https://danascape.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://danascape.github.io/ accesskey=h title="squadri (Alt + H)"><img src=https://danascape.github.io/apple-touch-icon.png alt aria-label=logo height=35>squadri</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://danascape.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://danascape.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://danascape.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Writing an Overlayed DTS</h1><div class=post-meta><span title='2021-09-21 00:00:00 +0530 IST'>September 21, 2021</span>&nbsp;·&nbsp;1164 words&nbsp;·&nbsp;squadri&nbsp;|&nbsp;<a href="mailto:saalim.priv@gmail.com?subject=/posts/1/index.md" rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation. Learn how to create them!</p><p><img loading=lazy src=/posts/1/img/overlayed_title.png></p><h2 id=basics>Basics<a hidden class=anchor aria-hidden=true href=#basics>#</a></h2><p>A device tree is a data structure for describing hardware.</p><p>Overlayed device trees are written in order to avoid changing the base device tree structures already present in the kernel source, and just get them overridden during compilation.</p><p>This will involve modifying OEM device trees from their import commit to a fully overlayed device tree; as an example, from <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/commit/d4fd8d9a664672056e4b68a31da298a4d4bc79ac>this</a> to <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/commit/85b3cb884acf30831a4185327a19a2c4268e457a>this</a>.</p><h2 id=steps>Steps<a hidden class=anchor aria-hidden=true href=#steps>#</a></h2><h3 id=1-find-the-initial-device-tree-import-for-your-device>1. Find the initial device tree import for your device<a hidden class=anchor aria-hidden=true href=#1-find-the-initial-device-tree-import-for-your-device>#</a></h3><p>For example, in my case on the device Asus X01AD (sdm632), they were added in <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/commit/d4fd8d9a664672056e4b68a31da298a4d4bc79ac>this</a> commit.</p><p>As you can see, most changes are additions done by the OEM.</p><p>Now, grab a dmesg from the stock kernel, and find the name of the DTB that your stock kernel uses. We will need it to create our initial base device tree.</p><p>You will find something like this in your dmesg (<em>start the dmesg from 0&rsquo;th second</em>).</p><p><code>Machine: Qualcomm Technologies, Inc. SDM632 PMI632 QRD SKU3</code></p><p>which implies our bootloader loads the dtb which points out to <code>SDM632 PMI632 QRD SKU3</code> Board Name.</p><h3 id=2-make-a-clean-base-of-your-kernel-which-just-boots>2. Make a clean base of your kernel which just boots<a hidden class=anchor aria-hidden=true href=#2-make-a-clean-base-of-your-kernel-which-just-boots>#</a></h3><p>For a clean kernel base, we add only the required changes on top of a base CAF (Code Aurora Forum) or ALS (Android Linux Stable) kernel source, which is enough to boot our device.</p><p>This minimal change-set differs from device to device, some devices might just boot on dts (device tree structure) imports but some devices might need additional changes in power or video drivers, and hence we must add all these as per requirement.</p><p>Before proceeding to write overlayed dts, I will consider that you have succeeded in booting your devices over a clean CAF or ALS base with minimal changes.</p><p>As an example, my <code>Asus X01AD</code> took quite a few changes to boot; you can look into it <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/tree/423c09527a97e55cca9a9ccfca247b1b179e3ebc>here</a>.</p><h3 id=3-get-to-know-the-device-tree>3. Get to know the device tree<a hidden class=anchor aria-hidden=true href=#3-get-to-know-the-device-tree>#</a></h3><p>Now stalk (well, research or learn about) your dtsi imports so that you can know what the OEM changed over the base source – the additions and deletions, addition of new panels and battery data, and so on.</p><h3 id=4-create-your-dts-file>4. Create your DTS file<a hidden class=anchor aria-hidden=true href=#4-create-your-dts-file>#</a></h3><p>Every device boots only on a single DTSI which points to the correct board name. In my case, it pointed to <code>SDM632 PMI632 QRD SKU3</code> as we saw in point 1, and I found <code>model = "Qualcomm Technologies, Inc. SDM632 + PMI632 SOC";</code> in <code>sdm632.dts</code>.</p><p>As per my convenience, I named it <code>sdm632-X01AD.dts</code> – you can choose whatever name you want. This will be the DTS which includes other overlayed DTS.</p><h3 id=5-make-our-kernel-build-our-new-dts>5. Make our kernel build our new DTS<a hidden class=anchor aria-hidden=true href=#5-make-our-kernel-build-our-new-dts>#</a></h3><p>You need to include the DTS in the <code>Makefile</code> of the <code>dts</code> directory – <code>arch/arm64/boot/dts/qcom/Makefile</code>, under the correct architecture name, <code>ARCH_SDM632</code> in this case.</p><p>You can call our DTS by inserting your <code>dtsname.dtb</code> under <code>architecture</code>, as seen in <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/commit/85b3cb884acf30831a4185327a19a2c4268e457a#diff-6ef2edc037b112b898a8ae8cf2e368a6cbc75dda5cc8a5dc9be6b1146ca4569dR10>this</a> commit. This is a bit different because I added guards in the <code>Makefile</code> to make sure only one DTB for my device is built, since it takes up space for no reason if the ones not needed are built too.</p><h3 id=6-organising-the-dts>6. Organising the DTS<a hidden class=anchor aria-hidden=true href=#6-organising-the-dts>#</a></h3><p>You can now create a directory to organise the various DTS files if you want to (I called it <code>X01AD</code>). You can also create sub-directories if you want, mainly to divide display panel DTS or the battery data DTS and so on, this is all upto you.</p><h3 id=7-identifying-the-dsi-panel-and-battery-data-dtsis>7. Identifying the DSI panel and battery data DTSIs<a hidden class=anchor aria-hidden=true href=#7-identifying-the-dsi-panel-and-battery-data-dtsis>#</a></h3><p>This step is for those who cannot recognise which dtsi are for DSI (Device Serial Interface) panels or battery data.</p><p>To find them, you can check names of DTSIs in your OEM import. This works in most cases. Display panel DTSI will look like <code>dsi-panel-"name-of-driver"-"resolution"-video.dtsi</code>.</p><p>Battery data DTSIs are different as per devices, so we will find them accordingly.</p><p>In my case, I found <code>dsi-panel-ili9881h-720p-video.dtsi</code> for display and <code>Huaqin_QL1830scud_4000mAh_averaged_MasterSlave_Sept25th2018_PMI632.dtsi</code> for battery data.</p><h3 id=8-creating-the-base-dtsi>8. Creating the base DTSI<a hidden class=anchor aria-hidden=true href=#8-creating-the-base-dtsi>#</a></h3><p>You now need to create a base DTSI in your custom directory and include it at the end of the <code>.dts</code> file we created in point 4.</p><p>You can include it as <code>#include "your-custom-directory/base.dtsi"</code>.</p><p>My base dtsi is <code>X01AD-base.dtsi</code> and is included in <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/commit/85b3cb884acf30831a4185327a19a2c4268e457a#diff-abc3be0451bc6bc9e957cd04db3f9bae2b34fbe57cd748e53adb8404d2aa57d2R31>this</a> commit.</p><p>Note that the base dtsi is created to bind up includes in a directory – it&rsquo;s upto you if you want to include other DTSIs from your base DTS or use my way, they&rsquo;re both fine.</p><h3 id=9-verifying-our-dtb-builds>9. Verifying our DTB builds<a hidden class=anchor aria-hidden=true href=#9-verifying-our-dtb-builds>#</a></h3><p>You can try to build your kernel and check if it goes fine. You can skip this step if you&rsquo;re confident about your work, it&rsquo;s just to confirm if our includes are correct.</p><p>In my case, I found my DTB built in <code>out/arch/arm64/boot/dts</code>.</p><p>Now – this might be discouraging, but we&rsquo;ve just begun; up until now, we haven&rsquo;t finished 10% of the work. Battery data and DSI panel changes are just additions, so that&rsquo;s the easiest part.</p><h3 id=10-checking-out-the-changes-in-dtsi-import-commit>10. Checking out the changes in DTSI import commit<a hidden class=anchor aria-hidden=true href=#10-checking-out-the-changes-in-dtsi-import-commit>#</a></h3><p>For example, let&rsquo;s take <code>msm8953.dtsi</code> as per <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/commit/d4fd8d9a664672056e4b68a31da298a4d4bc79ac#diff-e8966e9b69f2736b98f83b94f0850b361f5c3c01b12d71ec162dbefc02d732bdR72>this</a> commit.</p><p>Create a similar DTSI in your desired overlayed directory. This will make it easy for you and others to recall. In my case, it was <code>X01AD-msm8953.dtsi</code>.</p><p>Now include this in your base overlay DTS or DTSI that you created in your device directory.</p><h3 id=11-bringing-in-changes>11. Bringing in changes<a hidden class=anchor aria-hidden=true href=#11-bringing-in-changes>#</a></h3><p>Check the syntax in your OEM DTSI.</p><p>In my case, the DTSI starts with <code>/ {</code>.</p><p>DTSIs can start with braces (as you saw above) or nodes – <code>&amp;node</code>.</p><p>Now, let&rsquo;s have a look at another example.</p><p>In this <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/commit/d4fd8d9a664672056e4b68a31da298a4d4bc79ac#diff-e8966e9b69f2736b98f83b94f0850b361f5c3c01b12d71ec162dbefc02d732bdR72>line</a>, the address of the <code>other_ext</code> region has been changed.</p><p>In order to write that in our overlayed DTSI, write a new dtsi with <code>/ {</code>, and follow up till that address, the <code>other_ext_region</code>.</p><p>There&rsquo;s no need to include other regions, adresses, or nodes, since our OEM has not modified them, leaving them as-is to be included from the base DTSI.</p><p>This is an important step, since if it goes wrong, you will end up with weird cryptic errors from <code>dtc</code>. Our purpose can be to add, remove, or overwrite nodes, or to change regions, or add or remove properties.</p><p>If you understood the above your dtsi should look as such:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#728e00>/</span> {
</span></span><span style=display:flex><span>    <span style=color:#434f54>reserved</span><span style=color:#728e00>-</span><span style=color:#434f54>memory</span> {
</span></span><span style=display:flex><span>        <span style=color:#434f54>other_ext_mem</span>: <span style=color:#434f54>other_ext_region</span><span style=color:#a61717>@</span><span style=color:#8a7b52>0</span> {
</span></span></code></pre></div><p>It&rsquo;s now time to write our updated property:</p><p><code>reg = &lt;0x0 0x84a00000 0x0 0x1e00000>;</code></p><p>And now we just close the curly braces as per the syntax:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#728e00>/</span> {
</span></span><span style=display:flex><span>    <span style=color:#434f54>reserved</span><span style=color:#728e00>-</span><span style=color:#434f54>memory</span> {
</span></span><span style=display:flex><span>        <span style=color:#434f54>other_ext_mem</span>: <span style=color:#434f54>other_ext_region</span><span style=color:#a61717>@</span><span style=color:#8a7b52>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#434f54>reg</span> <span style=color:#728e00>=</span> <span style=color:#728e00>&lt;</span><span style=color:#8a7b52>0x0</span> <span style=color:#8a7b52>0x84a00000</span> <span style=color:#8a7b52>0x0</span> <span style=color:#8a7b52>0x1e00000</span><span style=color:#728e00>&gt;</span>;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>There you go – you just made the same OEM changes overlayed in a new DTSI which will now be overridden onto the base DTSI during compilation.</p><p>Other changes will also involve the same process, and you might need to delete nodes or properties as such:</p><p><code>/delete-property/ property-name;</code></p><p><code>/delete-node/ node-name;</code></p><p>Here&rsquo;s an <a href=https://github.com/stormbreaker-project/linux-asus-x01ad/commit/85b3cb884acf30831a4185327a19a2c4268e457a#diff-c7c6dacf6c6f713797447bf43699cfa3563f0a325f7261d7b35a64e263537db8R39>example</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://danascape.github.io/posts/2/><span class=title>« Prev</span><br><span>Android Device Tree Bringup</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://danascape.github.io/>Saalim Quadri</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>