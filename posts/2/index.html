<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android Device Tree Bringup | Saalim Quadri</title><meta name=keywords content><meta name=description content="Learn how to bring-up a device tree for your device so you can get started with building your favourite custom ROM!

Some of you guys might be wondering how people create your favorite custom ROMs like LineageOS, PixelExperience, HavocOS, and so on. I&rsquo;m here to guide you about the basics of a device tree and how to do a scratch bring-up of your own.
This article is a follow-up to my earlier article, Introduction to AOSP in which we discussed the fundamentals of and how to join the Android Open Source Project."><meta name=author content="squadri"><link rel=canonical href=https://danascape.github.io/posts/2/><link crossorigin=anonymous href=/assets/css/stylesheet.ecb14332dfba04052a266caa0f33168daa8dd2df45fe49adcb98d99df3cb40f6.css integrity="sha256-7LFDMt+6BAUqJmyqDzMWjaqN0t9F/kmty5jZnfPLQPY=" rel="preload stylesheet" as=style><link rel=icon href=https://danascape.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://danascape.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://danascape.github.io/favicon.ico><link rel=apple-touch-icon href=https://danascape.github.io/favicon.ico><link rel=mask-icon href=https://danascape.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://danascape.github.io/posts/2/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WDDV94BTDD"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WDDV94BTDD")}</script><meta property="og:url" content="https://danascape.github.io/posts/2/"><meta property="og:site_name" content="Saalim Quadri"><meta property="og:title" content="Android Device Tree Bringup"><meta property="og:description" content="Learn how to bring-up a device tree for your device so you can get started with building your favourite custom ROM!
Some of you guys might be wondering how people create your favorite custom ROMs like LineageOS, PixelExperience, HavocOS, and so on. I’m here to guide you about the basics of a device tree and how to do a scratch bring-up of your own.
This article is a follow-up to my earlier article, Introduction to AOSP in which we discussed the fundamentals of and how to join the Android Open Source Project."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-04T00:00:00+05:30"><meta property="article:modified_time" content="2021-10-04T00:00:00+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android Device Tree Bringup"><meta name=twitter:description content="Learn how to bring-up a device tree for your device so you can get started with building your favourite custom ROM!

Some of you guys might be wondering how people create your favorite custom ROMs like LineageOS, PixelExperience, HavocOS, and so on. I&rsquo;m here to guide you about the basics of a device tree and how to do a scratch bring-up of your own.
This article is a follow-up to my earlier article, Introduction to AOSP in which we discussed the fundamentals of and how to join the Android Open Source Project."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://danascape.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Android Device Tree Bringup","item":"https://danascape.github.io/posts/2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android Device Tree Bringup","name":"Android Device Tree Bringup","description":"Learn how to bring-up a device tree for your device so you can get started with building your favourite custom ROM!\nSome of you guys might be wondering how people create your favorite custom ROMs like LineageOS, PixelExperience, HavocOS, and so on. I\u0026rsquo;m here to guide you about the basics of a device tree and how to do a scratch bring-up of your own.\nThis article is a follow-up to my earlier article, Introduction to AOSP in which we discussed the fundamentals of and how to join the Android Open Source Project.\n","keywords":[],"articleBody":"Learn how to bring-up a device tree for your device so you can get started with building your favourite custom ROM!\nSome of you guys might be wondering how people create your favorite custom ROMs like LineageOS, PixelExperience, HavocOS, and so on. I’m here to guide you about the basics of a device tree and how to do a scratch bring-up of your own.\nThis article is a follow-up to my earlier article, Introduction to AOSP in which we discussed the fundamentals of and how to join the Android Open Source Project.\nPrerequisites Certain requirements are to be met before starting the bringup.\nAbility to understand basic editing/writing of files and text, familiarity with the command line interface and some basic git knowledge.\nA machine powerful enough to build Android – you can check the basic requirements here.\nPossess a fundamental understanding of the Android Open Source Project’s build system, commands, and other aspects. You can read more about it here.\nNote: This guide only applies to devices launched with Project Treble enabled (Android Oreo 8.0+). The device tree I’m using as a reference is a Qualcomm SDM632 (MSM8953) based tree, launched with Android 8.1. The guide uses LineageOS as the Android ROM Build System. Each ROM can have their own unique build system which might differ. The partition table of devices might differ from the device taken as an example below. Understanding Basic Structure Android device trees are certain bits and bytes of Makefile code that allows the Android build system to recognize the specifications of the target device, and what all is to be built along with it.\nAfter reading this guide, you will be able to bringup a prebuilt vendor based device tree (will explain what that means in a while).\nTo start, let’s look at a basic bringup: These certain files and folders are ones we come across in every other device tree.\nLet’s break down the important ones:\nAndroid.mk: This is the most basic Makefile definition for any path to be included in the Android build system. This Makefile calls for all other Makefiles present in the all the directories and subdirectories of the device tree. The basic use of this specific Makefile is to guard the device tree Makefiles when not building for our target device. BoardConfig.mk: This contains the Board (SoC/Chipset) specific definition, such as the architecture (arm, arm64, x86, so on), the required build flags and the kernel build flags. These flags aid the build process. aosp_\u003cdevice-name\u003e.mk: This is a common Makefile found in most AOSP trees. This specific Makefile defines device name, manufacturer and build product details and is also used to call device.mk described below. AndroidProducts.mk: This Makefile includes the device product Makefiles, i.e. the aforementioned aosp_\u003cdevice-name\u003e.mk on lunch (term used to initialise device trees for build). This Makefile also defines the lunch target (Android 10+). device.mk: This Makefile contains all the build targets and copy specifications such as audio configs, feature configs, and so on. If you want a certain package to be built inline with Android ROM builds, this where you’d want to define it. The vendor tree Makefiles are also called from here. vendorsetup.sh: This shell script was superceded by AndroidProducts.mk after Android 10. Note: Not all the contents of a device tree are needed to be brought up from scratch since only certain files differ as per device and chipset, so I mentioned only the required ones. Starting the Bringup Now that we know the basic structure of an android device tree, let’s start our bringup.\nA prebuilt vendor based device tree is the one which uses device OEM vendor to run ROM. Basically while flashing ROMs based on this device tree you do not need to wipe vendor. You’ll need to figure out the codename of the device by looking at the build number or reading the build.prop or checking the stock rom dump. This is not important and you can use any codename for your device. P/S : My friend chose amogus as his device’s codename.\nYou’ll also need to create a directory where your device tree will be placed and called by Android Build System. According to Google devices, you can create this directory in device/device-implementer/device-name/, where the device implementer is the device manufacturer, such as asus, google, oneplus, oppo, realme, xiaomi, and so on.\nStarting with Android.mk It must begin by defining the LOCAL_PATH variable such that android build system can call the makefile: LOCAL_PATH := $(call my-dir) Now we would need to guard our device Makefiles to only be called when it’s mentioned in lunch: ifeq ($(TARGET_DEVICE),) endif This means that it will start including the device tree only if the TARGET_DEVICE variable is set to your device.\nIn order for our Android Makefile to include all other makefiles in the directory or sub directories, you can do it as:\nifeq ($(TARGET_DEVICE),) include $(call all-makefiles-under,$(LOCAL_PATH)) endif In my case, the device’s codename is X01AD, so in the end it should look like this:\nLOCAL_PATH := $(call my-dir) ifeq ($(TARGET_DEVICE),X01AD) include $(call all-makefiles-under,$(LOCAL_PATH)) endif This concludes the basic Android.mk structure.\nMoving on to BoardConfig.mk As the name suggests, it includes board specific variables, such as chipset or device specific feature flags. There’s a certain set of flags that are important for all devices, such as the architecture, command line and partition information. Since I have an arm64 based Qualcomm device, I can start with setting up base architecture as such:\nTARGET_ARCH := arm64 TARGET_ARCH_VARIANT := armv8-a TARGET_CPU_ABI := arm64-v8a TARGET_CPU_ABI2 := TARGET_CPU_VARIANT := generic and a fallback secondary architecture as:\nTARGET_2ND_ARCH := arm TARGET_2ND_ARCH_VARIANT := armv8-a TARGET_2ND_CPU_ABI := armeabi-v7a TARGET_2ND_CPU_ABI2 := armeabi TARGET_2ND_CPU_VARIANT := generic The Android build server generates build artifacts and VNDK snapshot files using the following build parameters. You can read more about them here and here.\nFor those who have an arm based device, you can just set:\nTARGET_ARCH := arm TARGET_ARCH_VARIANT := armv8-a TARGET_CPU_ABI := armeabi-v7a TARGET_CPU_ABI2 := armeabi TARGET_CPU_VARIANT := generic These are global variables and can be used for all devices. Developers might change CPU variants according to chipsets but that’s not necessary.\nNow, you need to define your device bootloader variables as such: TARGET_BOOTLOADER_BOARD_NAME := #(Based on your device) TARGET_NO_BOOTLOADER := true #(For source to not build bootloader) For my device it looks like this:\nMoving on to the kernel build system We will set up the required flags as per the LineageOS build system.\nIn Android, Qualcomm (QCOM) and Mediatek (MTK) chipsets set some kernel parameters which are picked up by their Operating System (the preloaded stock ROM). They are set in device tree source as a kernel cmdline parameter this way:\n# You can have additional values to the same flag by using the append symbol (\"+=\") instead of initialise symbol (\":=\") BOARD_KERNEL_CMDLINE := #(This is initialised) BOARD_KERNEL_CMDLINE += You can obtain your device cmdline by unpacking your stock firmware bootimage using mkbootimg tools from here. During unpack you will obtain an output with kernel cmdline which looks like:\ncmd_line='console=ttyMSM0,115200n8 androidboot.hardware=qcom androidboot.console=ttyMSM0 androidboot.memcg=1 lpm_levels.sleep_disabled=1 video=vfb:640x400,bpp=32,memsize=3072000 msm_rtb.filter=0x237 service_locator.enable=1 swiotlb=1 androidboot.usbcontroller=a600000.dwc3 earlycon=msm_geni_serial,0x880000 loop.max_part=7'\nSo after setting up your kernel cmdline you need to set some base kernel flags which matches your stock bootimage in order for it to boot up your device:\nBOARD_KERNEL_BASE := BOARD_KERNEL_PAGESIZE := BOARD_KERNEL_TAGS_OFFSET := BOARD_RAMDISK_OFFSET := They can be obtained from mkbootimg tools during unpack of your stock firmware bootimage. Read more about them here.\nAfter setting the flags, we want our kernel source to get built; as per the LineageOS build system we can either build our kernel from source or use prebuilt binaries as per our convenience. Usage of a source built kernel looks like this:\nTARGET_KERNEL_CONFIG := #(Kernel Config name to be picked up as per architecture from kernel-source-path/arch//configs/) TARGET_KERNEL_SOURCE := #(Your kernel source path from root of Android source) After setting up your flags it should look like this:\nBOARD_KERNEL_CMDLINE := console=ttyMSM0,115200,n8 androidboot.hardware=qcom BOARD_KERNEL_CMDLINE += androidboot.console=ttyMSM0 BOARD_KERNEL_CMDLINE += msm_rtb.filter=0x237 ehci-hcd.park=3 BOARD_KERNEL_CMDLINE += lpm_levels.sleep_disabled=1 BOARD_KERNEL_CMDLINE += androidboot.bootdevice=7824900.sdhci BOARD_KERNEL_CMDLINE += earlycon=msm_serial_dm,0x78af000 BOARD_KERNEL_CMDLINE += firmware_class.path=/vendor/firmware_mnt/image BOARD_KERNEL_CMDLINE += androidboot.usbconfigfs=true BOARD_KERNEL_CMDLINE += loop.max_part=7 BOARD_KERNEL_CMDLINE += androidboot.selinux=permissive BOARD_KERNEL_BASE := 0x80000000 BOARD_KERNEL_PAGESIZE := 2048 BOARD_KERNEL_IMAGE_NAME := Image.gz-dtb BOARD_KERNEL_TAGS_OFFSET := 0x00000100 BOARD_RAMDISK_OFFSET := 0x01000000 TARGET_KERNEL_CONFIG := X01AD_defconfig TARGET_KERNEL_SOURCE := kernel/asus/X01AD A configuration with prebuilt kernel should look like this:\nBOARD_KERNEL_CMDLINE := console=ttyMSM0,115200,n8 androidboot.hardware=qcom BOARD_KERNEL_CMDLINE += androidboot.console=ttyMSM0 BOARD_KERNEL_CMDLINE += msm_rtb.filter=0x237 ehci-hcd.park=3 BOARD_KERNEL_CMDLINE += lpm_levels.sleep_disabled=1 BOARD_KERNEL_CMDLINE += androidboot.bootdevice=7824900.sdhci BOARD_KERNEL_CMDLINE += earlycon=msm_serial_dm,0x78af000 BOARD_KERNEL_CMDLINE += firmware_class.path=/vendor/firmware_mnt/image BOARD_KERNEL_CMDLINE += androidboot.usbconfigfs=true BOARD_KERNEL_CMDLINE += loop.max_part=7 BOARD_KERNEL_CMDLINE += androidboot.selinux=permissive BOARD_KERNEL_BASE := 0x80000000 BOARD_KERNEL_PAGESIZE := 2048 BOARD_KERNEL_IMAGE_NAME := Image.gz-dtb BOARD_KERNEL_TAGS_OFFSET := 0x00000100 BOARD_RAMDISK_OFFSET := 0x01000000 TARGET_PREBUILT_KERNEL := device/asus/X01AD-kernel/Image.gz-dtb Source will pick up these offset flags for use in mkboot arguments, so there’s no need to set them again in the BoardConfig.\nMoving on to partition flags Different devices have different partition sizes and names. I will using my QCOM device as a reference, but it might be different for your device.\nBasically, a built Android OS flashable ZIP flashes over the boot, cache, recovery and system partitions.\nAfter Android 8.0, a new partition named vendor was introduced (Project Treble).\n#(Comment need to do something here and redirect over project treble)\nAfter more Android releases more partitions were introduced, so as per Android 11 convention, the partition used by Android are boot, cache, odm, product, recovery, system, system_ext, vendor. These are basic names and may change (like system_a, system_b for A/B devices).\nYou can check path of your partitions using:\nls -l /dev/block/bootdevice/by-name This path works for most of generic devices and may change.\nNow in order to obtain partition sizes\nblockdev --getsize64 Example:\nblockdev --getsize64 /dev/block/bootdevice/by-name/system This will give output of your partition sizes in bytes, you can directly set it as a flag variable so no need to convert the values.\nFor prebuilt vendor based device trees, you can just fetch partition sizes for boot, cache, odm, product, recovery, system, system_ext, and userdata (/data).\nNo need to worry if you do not have a certain partition – this list is tentative.\nAfter obtaining the partition sizes to set them as flags you can do this:\nBOARD_IMAGE_PARTITION_SIZE := Example:\nBOARD_SYSTEMIMAGE_PARTITION_SIZE := 4294967296 After that you need to set partition filesystem type, this can be f2fs, ext2, ext3, ext4, and so on. You can find your partition filesystem type in your device fstab located in /vendor/etc/fstab.qcom\nTo set partition file system type you can do this:\nBOARD_IMAGE_FILE_SYSTEM_TYPE := Setting file system time for partitions is not important as the Android build system will pick default types if you do not set them, but the partition userdata is an exception where it is absolutely necessary to defined the filesystem type and the flags for doing so are different, namely:\nTARGET_USERIMAGES_USE_EXT4 := true # or TARGET_USERIMAGES_USE_F2FS:= true After setting up your partition flags and file system types, it should look like this:\n# Partitions - Boot BOARD_BOOTIMAGE_PARTITION_SIZE := 67108864 BOARD_FLASH_BLOCK_SIZE := 131072 # (BOARD_KERNEL_PAGESIZE * 64) # Partitions - Cache BOARD_CACHEIMAGE_PARTITION_SIZE := 367001600 BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE := ext4 # Partitions - Recovery BOARD_RECOVERYIMAGE_PARTITION_SIZE := 67108864 # Partitions - System BOARD_SYSTEMIMAGE_PARTITION_SIZE := 4294967296 # Partitions - Userdata BOARD_USERDATAIMAGE_PARTITION_SIZE := 55423516160 Note: keep in mind that these are different as per devices.\nMoving on to Device Platform It can be set this way:\nTARGET_BOARD_PLATFORM := it can be msm8937, msm8953, sdm660, and so on. It is to be set according to your device. It is a CAF variable which is picked up by the LineageOS build system in order to build chipset specific HALs (We will learn about this later).\nMoving on to Recovery fstab Won’t explain much about it since you can read it here.\nSo after reading the above thread, you can take your device fstab which can be found in /vendor/etc/fstab.qcom (fstab.qcom in my case, it can be anything else for other chipset devices, fstab.qcom is picked up by our bootloader) and set the flag pointing out it in device tree.\nTARGET_RECOVERY_FSTAB := fstab-path-in-device-source/fstab.qcom Example:\nTARGET_RECOVERY_FSTAB := $(DEVICE_PATH)/rootdir/etc/fstab.qcom Generating VNDK Snapshots Vendor Native Development Kit, check it out in brief here.\nYou can set BoardConfig flags as read above and set the VNDK version as per your desired vendor.\nAs a default behaviour, source sets BOARD_VNDK_VERSION := current, here current implies vndk version of current android source (like 29 for Q, 30 for R).\nSuppose you are trying to build Android Q for a vendor based on Android 9 – you can then set PRODUCT_TARGET_VNDK_VERSION := value as per your vendor (28 for Pie).\nYou can also include additional VNDK snapshots for your vendor, like if you want Oreo vndk snapshots as well as Pie, you can set PRODUCT_EXTRA_VNDK_VERSIONS := value as you desire.\nSEPolicy / SELinux Setting SEPolicy is not very important for prebuilt vendor based device trees as most of selinux rules are defined in vendor sepolicy.\nYou can read about SEPolicy here.\nYour device will proceed onto boot animation on SELinux due to the same reason as listed above, so you can just fixup the remaining denials by setting up SELinux on the system side.\nThis can be done by including QCOM sepolicy (Board specific since this guide is for QCOM boards).\nBOARD_PLAT_PRIVATE_SEPOLICY_DIR += device/qcom/sepolicy/private BOARD_PLAT_PUBLIC_SEPOLICY_DIR += device/qcom/sepolicy/public This is global and can be used by any device, BOARD_PLAT implies SEPolicy will be updated in system side.\nSimilarly BOARD_PRODUCT for product side.\nCalling out vendor BoardConfig Makefile Include your vendor device makefile as: # Inherit from the proprietary version include vendor/device-implementer/device-name/BoardConfigVendor.mk Example:-\n# Inherit from the proprietary version include vendor/asus/X01AD/BoardConfigVendor.mk We will learn more about vendor a bit later.\nStarting out with device product Source calls device product which relatively calls other Makefiles present in the device tree. By default when a product Makefile is called, it also includes the BoardConfig Makefile, so we don’t need to include it. A device product Makefile looks like ROM-name_device-name.mk, for example lineage_X01AD.mk. This can change accordingly for other ROMs. In the device product Makefile you can configure if you want 64/32-bit apps to run on your system, whether your device will have telephony (radio in basic words) or if it is wifi-only, and so on. These Makefiles are found in build/target/product in the source directory. According to basic Makefile syntax rules we can call another Makefile by using $(call inherit-product, ).\nIn Android source, there is a variable which sets path for build/target, i.e $(SRC_TARGET_DIR), So in order to call a Makefile from target product we can just use $(SRC_TARGET_DIR)/product/.\nYou can read these Makefiles for more information.\nDevice product Makefile is also used to call the ROM specific common Makefile (mainly ROM specific features). You can find these Makefiles in vendor/ROM-name/config/ which will be vendor/lineage/config in our case. We can call it this way:\n$(call inherit-product, vendor/lineage/config/common_full_phone.mk) In the end, we need to set device name and product name which should match our ROM-name. Example:\n# Device identifiers. PRODUCT_NAME := lineage_X01AD PRODUCT_DEVICE := X01AD PRODUCT_MANUFACTURER := asus PRODUCT_BRAND := asus PRODUCT_MODEL := ASUS_X01AD These are basic device identifiers and I don’t think further explanation is required since they’re fairly self-explanatory.\nCalling our device product Since Android Q, we need to create AndroidProducts.mk in order to call our device product makefile. This can be done this way:\nPRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/ROM-name_device-name.mk Example:\nPRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/lineage_X01AD.mk You can find a reference commit to set device product here.\nLast but not the least You need to call this Makefile from device product Makefile: $(call inherit-product, device/device-implementer/device-name/device.mk) Example:\n# Inherit from X01AD device $(call inherit-product, device/asus/X01AD/device.mk) We create a device makefile in our device tree which defines package names or device dimensions or screen density. Some basic flags are lister here:\n# Boot animation TARGET_SCREEN_HEIGHT := TARGET_SCREEN_WIDTH := # Device uses high-density artwork where available PRODUCT_AAPT_CONFIG := PRODUCT_AAPT_PREF_CONFIG := You can also inherit your device proprietary system files (will explain a bit later) as follows: $(call inherit-product-if-exists, vendor/device-implementer/device-name/device-name-vendor.mk) Customizing the build with overlays Android build system uses overlays to customize or override resource values specifically for a product. To use overlays, modify the project device Makefile to set PRODUCT_PACKAGE_OVERLAYS to a path relative to your top-level directory. You can do it as follows:\nPRODUCT_PACKAGE_OVERLAYS := device/device-implementer/device-name/overlay Default overlays can be found by extracting frameworks-res from your stock device dump using apktool (not in scope of this guide). Note that overlays are not important to boot the ROM on your device. They are used to overwrite certain properties or values over source to fixup certain bugs related to dimensions or similar. Read more about overlays and how they work here. Setting up device vendor There are certain libraries and APKs which are not source buildable (or proprietary) but are important for devices to have in order to gain some features or functionalities. These libraries or apps are listed in separate repo with proprietary files. In order to generate this repository, we extract the required proprietary libraries or apps from stock OEM firmware using proprietary extract scripts. These scripts are present in ROM side in certain ROMs which can be picked up from basic scripts which we set in our device trees, and which define certain variables and helps in generating a Makefile to ease our work and just call the repo in order to get started. At first you can pick these device-side shell scripts from here and modify them based on your device product name and manufacturer. Before running your shell scripts create a proprietary files list as per your device called proprietary-files.txt this way: # ANT -lib/libantradio.so -lib64/libantradio.so product/lib/com.qualcomm.qti.ant@1.0.so product/lib64/com.qualcomm.qti.ant@1.0.so # Alarm product/framework/vendor.qti.hardware.alarm-V1.0-java.jar # Audio etc/permissions/audiosphere.xml framework/audiosphere.jar This is a section of my current proprietary list and it can be different for other devices. You can find my full system-side listing here.\nNow, hoping that your list is created and all went well, in order to run extract-files.sh, you need adb support on your system or device dump where you can point out script to extract. You can read these scripts in order to check how they work and extract. After you run these scripts, it will extract the apps and libs listed in your proprietary files and will setup makefiles in a separate directory which can be called as listed above in BoardConfig and device makefile section. Getting things running If all above goes well, you can go to your ROM source directory and lunch the device product (I will not explain how to start build as its a basic requirement to know how to build a ROM before you do a bringup). Start your build and let it complete. These are only basic requirements for a device to get built and booting it is a different thing. Sometimes your ROM might get stuck on logo or stuck on endless boot animation, you will need to debug these issues in order to get things running. I will list up some reference system-only device trees that you can learn from. danascape/device_asus_X01AD\ndanascape/device_oneplus_billie\ndanascape/device_xiaomi_olive\ndanascape/device_xiaomi_violet\nCertain device might need more things in order to get booting. These things might include AB or dynamic partition based BoardConfig flags, boot control HAL or gpt-utils or some extra libs. You can check more about how I did these things in above references. Let me know your new experiences at my email.\n","wordCount":"3190","inLanguage":"en","datePublished":"2021-10-04T00:00:00+05:30","dateModified":"2021-10-04T00:00:00+05:30","author":{"@type":"Person","name":"squadri"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://danascape.github.io/posts/2/"},"publisher":{"@type":"Organization","name":"Saalim Quadri","logo":{"@type":"ImageObject","url":"https://danascape.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://danascape.github.io/ accesskey=h title="squadri (Alt + H)"><img src=https://danascape.github.io/apple-touch-icon.png alt aria-label=logo height=35>squadri</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://danascape.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://danascape.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://danascape.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Android Device Tree Bringup</h1><div class=post-meta><span title='2021-10-04 00:00:00 +0530 IST'>October 4, 2021</span>&nbsp;·&nbsp;3190 words&nbsp;·&nbsp;squadri&nbsp;|&nbsp;<a href="mailto:saalim.priv@gmail.com?subject=/posts/2/index.md" rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Learn how to bring-up a device tree for your device so you can get started with building your favourite custom ROM!</p><p><img loading=lazy src=/posts/2/img/devicetree_bringup_title.jpg></p><p>Some of you guys might be wondering how people create your favorite custom ROMs like LineageOS, PixelExperience, HavocOS, and so on. I&rsquo;m here to guide you about the basics of a device tree and how to do a scratch bring-up of your own.</p><p>This article is a follow-up to my earlier article, <a href=https://blog.realogs.in/getting-started-with-aosp/>Introduction to AOSP</a> in which we discussed the fundamentals of and how to join the Android Open Source Project.</p><h3 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h3><p>Certain requirements are to be met before starting the bringup.</p><ol><li><p>Ability to understand basic editing/writing of files and text, familiarity with the command line interface and some basic git knowledge.</p></li><li><p>A machine powerful enough to build Android – you can check the basic requirements <a href=https://source.android.com/setup/build/requirements>here</a>.</p></li><li><p>Possess a fundamental understanding of the Android Open Source Project&rsquo;s build system, commands, and other aspects. You can read more about it <a href=https://blog.realogs.in/getting-started-with-aosp/>here</a>.</p></li></ol><h3 id=note>Note:<a hidden class=anchor aria-hidden=true href=#note>#</a></h3><ul><li>This guide only applies to devices launched with Project Treble enabled (Android Oreo 8.0+).</li><li>The device tree I&rsquo;m using as a reference is a Qualcomm SDM632 (MSM8953) based tree, launched with Android 8.1.</li><li>The guide uses LineageOS as the Android ROM Build System. Each ROM can have their own unique build system which might differ.</li><li>The partition table of devices might differ from the device taken as an example below.</li></ul><h2 id=understanding-basic-structure>Understanding Basic Structure<a hidden class=anchor aria-hidden=true href=#understanding-basic-structure>#</a></h2><p>Android device trees are certain bits and bytes of <code>Makefile</code> code that allows the Android build system to recognize the specifications of the target device, and what all is to be built along with it.</p><p>After reading this guide, you will be able to bringup a prebuilt vendor based device tree (will explain what that means in a while).</p><p>To start, let&rsquo;s look at a basic bringup:
<img loading=lazy src=/posts/2/img/x01ad-dt-home.jpg></p><p>These certain files and folders are ones we come across in every other device tree.</p><p>Let&rsquo;s break down the important ones:</p><ul><li><strong>Android.mk</strong>: This is the most basic <code>Makefile</code> definition for any path to be included in the Android build system. This <code>Makefile</code> calls for all other <code>Makefiles</code> present in the all the directories and subdirectories of the device tree. The basic use of this specific <code>Makefile</code> is to guard the device tree <code>Makefiles</code> when not building for our target device.</li><li><strong>BoardConfig.mk</strong>: This contains the Board (SoC/Chipset) specific definition, such as the architecture (arm, arm64, x86, so on), the required build flags and the kernel build flags. These flags aid the build process.</li><li><strong>aosp_&lt;<em>device-name</em>>.mk</strong>: This is a common <code>Makefile</code> found in most AOSP trees. This specific <code>Makefile</code> defines device name, manufacturer and build product details and is also used to call <strong>device.mk</strong> described below.</li><li><strong>AndroidProducts.mk</strong>: This <code>Makefile</code> includes the device product <code>Makefiles</code>, i.e. the aforementioned <strong>aosp_&lt;<em>device-name</em>>.mk</strong> on <code>lunch</code> (term used to initialise device trees for build). This <code>Makefile</code> also defines the lunch target (Android 10+).</li><li><strong>device.mk</strong>: This <code>Makefile</code> contains all the build targets and copy specifications such as audio configs, feature configs, and so on. If you want a certain package to be built inline with Android ROM builds, this where you&rsquo;d want to define it. The vendor tree <code>Makefiles</code> are also called from here.</li><li><strong>vendorsetup.sh</strong>: This shell script was superceded by <code>AndroidProducts.mk</code> after Android 10.</li></ul><h3 id=note-1>Note:<a hidden class=anchor aria-hidden=true href=#note-1>#</a></h3><ul><li>Not all the contents of a device tree are needed to be brought up from scratch since only certain files differ as per device and chipset, so I mentioned only the required ones.</li></ul><h2 id=starting-the-bringup>Starting the Bringup<a hidden class=anchor aria-hidden=true href=#starting-the-bringup>#</a></h2><p>Now that we know the basic structure of an android device tree, let&rsquo;s start our bringup.</p><ul><li>A prebuilt vendor based device tree is the one which uses device OEM vendor to run ROM. Basically while flashing ROMs based on this device tree you do not need to wipe vendor.</li><li>You&rsquo;ll need to figure out the codename of the device by looking at the <strong>build number</strong> or <strong>reading the build.prop</strong> or <strong>checking the stock rom dump</strong>. This is not important and you can use any codename for your device.</li></ul><p>P/S : My friend chose amogus as his device&rsquo;s codename.</p><ul><li>You&rsquo;ll also need to create a directory where your device tree will be placed and called by Android Build System.</li></ul><p>According to Google devices, you can create this directory in <code>device/device-implementer/device-name/</code>, where the device implementer is the device manufacturer, such as <code>asus</code>, <code>google</code>, <code>oneplus</code>, <code>oppo</code>, <code>realme</code>, <code>xiaomi</code>, and so on.</p><h2 id=starting-with-androidmk>Starting with Android.mk<a hidden class=anchor aria-hidden=true href=#starting-with-androidmk>#</a></h2><ul><li>It must begin by defining the <code>LOCAL_PATH</code> variable such that android build system can call the makefile:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>LOCAL_PATH</span> <span style=color:#728e00>:=</span> <span style=color:#728e00>$(</span>call my-dir<span style=color:#728e00>)</span>
</span></span></code></pre></div><ul><li>Now we would need to guard our device <code>Makefiles</code> to only be called when it&rsquo;s mentioned in <code>lunch</code>:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#a61717>ifeq</span> <span style=color:#a61717>(</span><span style=color:#728e00>$(</span><span style=color:#434f54>TARGET_DEVICE</span><span style=color:#728e00>)</span><span style=color:#a61717>,&lt;device-codename&gt;)</span>
</span></span><span style=display:flex><span><span style=color:#a61717>endif</span>
</span></span></code></pre></div><p>This means that it will start including the device tree <strong>only</strong> if the <code>TARGET_DEVICE</code> variable is set to your device.</p><p>In order for our Android <code>Makefile</code> to include all other makefiles in the directory or sub directories, you can do it as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#a61717>ifeq</span> <span style=color:#a61717>(</span><span style=color:#728e00>$(</span><span style=color:#434f54>TARGET_DEVICE</span><span style=color:#728e00>)</span><span style=color:#a61717>,&lt;device-codename&gt;)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a61717>include</span> <span style=color:#728e00>$(</span><span style=color:#434f54>call</span> <span style=color:#434f54>all</span>-<span style=color:#434f54>makefiles</span>-<span style=color:#434f54>under</span>,<span style=color:#728e00>$(</span><span style=color:#434f54>LOCAL_PATH</span><span style=color:#728e00>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a61717>endif</span>
</span></span></code></pre></div><p>In my case, the device&rsquo;s codename is X01AD, so in the end it should look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>LOCAL_PATH</span> <span style=color:#728e00>:=</span> <span style=color:#728e00>$(</span>call my-dir<span style=color:#728e00>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a61717>ifeq</span> <span style=color:#a61717>(</span><span style=color:#728e00>$(</span><span style=color:#434f54>TARGET_DEVICE</span><span style=color:#728e00>)</span><span style=color:#a61717>,X01AD)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a61717>include</span> <span style=color:#728e00>$(</span><span style=color:#434f54>call</span> <span style=color:#434f54>all</span>-<span style=color:#434f54>makefiles</span>-<span style=color:#434f54>under</span>,<span style=color:#728e00>$(</span><span style=color:#434f54>LOCAL_PATH</span><span style=color:#728e00>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a61717>endif</span>
</span></span></code></pre></div><p>This concludes the basic <code>Android.mk</code> structure.</p><h2 id=moving-on-to-boardconfigmk>Moving on to BoardConfig.mk<a hidden class=anchor aria-hidden=true href=#moving-on-to-boardconfigmk>#</a></h2><ul><li>As the name suggests, it includes board specific variables, such as chipset or device specific feature flags.</li><li>There&rsquo;s a certain set of flags that are important for all devices, such as the architecture, command line and partition information.</li></ul><p>Since I have an <code>arm64</code> based Qualcomm device, I can start with setting up base architecture as such:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_ARCH</span> <span style=color:#728e00>:=</span> arm64
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_ARCH_VARIANT</span> <span style=color:#728e00>:=</span> armv8-a
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_CPU_ABI</span> <span style=color:#728e00>:=</span> arm64-v8a
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_CPU_ABI2</span> <span style=color:#728e00>:=</span>
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_CPU_VARIANT</span> <span style=color:#728e00>:=</span> generic
</span></span></code></pre></div><p>and a fallback secondary architecture as:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_2ND_ARCH</span> <span style=color:#728e00>:=</span> arm
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_2ND_ARCH_VARIANT</span> <span style=color:#728e00>:=</span> armv8-a
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_2ND_CPU_ABI</span> <span style=color:#728e00>:=</span> armeabi-v7a
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_2ND_CPU_ABI2</span> <span style=color:#728e00>:=</span> armeabi
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_2ND_CPU_VARIANT</span> <span style=color:#728e00>:=</span> generic
</span></span></code></pre></div><p>The Android build server generates build artifacts and VNDK snapshot files using the following build parameters. You can read more about them <a href=https://developer.android.com/ndk/guides/abis#cmake>here</a> and <a href=https://source.android.com/docs/core/architecture/vndk/snapshot-generate>here</a>.</p><p>For those who have an <code>arm</code> based device, you can just set:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_ARCH</span> <span style=color:#728e00>:=</span> arm
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_ARCH_VARIANT</span> <span style=color:#728e00>:=</span> armv8-a
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_CPU_ABI</span> <span style=color:#728e00>:=</span> armeabi-v7a
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_CPU_ABI2</span> <span style=color:#728e00>:=</span> armeabi
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_CPU_VARIANT</span> <span style=color:#728e00>:=</span> generic
</span></span></code></pre></div><p>These are global variables and can be used for all devices. Developers might change CPU variants according to chipsets but that&rsquo;s not necessary.</p><ul><li>Now, you need to define your device bootloader variables as such:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_BOOTLOADER_BOARD_NAME</span> <span style=color:#728e00>:=</span> <span style=color:#95a5a6>#(Based on your device)</span>
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_NO_BOOTLOADER</span> <span style=color:#728e00>:=</span> <span style=color:#728e00>true</span> <span style=color:#95a5a6>#(For source to not build bootloader)</span>
</span></span></code></pre></div><p>For my device it looks like this:</p><h2 id=moving-on-to-the-kernel-build-system>Moving on to the kernel build system<a hidden class=anchor aria-hidden=true href=#moving-on-to-the-kernel-build-system>#</a></h2><p>We will set up the required flags as per the LineageOS build system.</p><p>In Android, Qualcomm (QCOM) and Mediatek (MTK) chipsets set some kernel parameters which are picked up by their Operating System (the preloaded stock ROM). They are set in device tree source as a kernel cmdline parameter this way:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#95a5a6># You can have additional values to the same flag by using the append symbol (&#34;+=&#34;) instead of initialise symbol (&#34;:=&#34;)
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>:=</span> <span style=color:#95a5a6>#(This is initialised)</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span>
</span></span></code></pre></div><p>You can obtain your device cmdline by unpacking your stock firmware bootimage using mkbootimg tools from <a href=https://github.com/LineageOS/android_system_core/tree/lineage-17.1/mkbootimg>here</a>. During unpack you will obtain an output with kernel cmdline which looks like:</p><p><code>cmd_line='console=ttyMSM0,115200n8 androidboot.hardware=qcom androidboot.console=ttyMSM0 androidboot.memcg=1 lpm_levels.sleep_disabled=1 video=vfb:640x400,bpp=32,memsize=3072000 msm_rtb.filter=0x237 service_locator.enable=1 swiotlb=1 androidboot.usbcontroller=a600000.dwc3 earlycon=msm_geni_serial,0x880000 loop.max_part=7'</code></p><p>So after setting up your kernel cmdline you need to set some base kernel flags which matches your stock bootimage in order for it to boot up your device:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_BASE</span> <span style=color:#728e00>:=</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_PAGESIZE</span> <span style=color:#728e00>:=</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_TAGS_OFFSET</span> <span style=color:#728e00>:=</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_RAMDISK_OFFSET</span> <span style=color:#728e00>:=</span>
</span></span></code></pre></div><p>They can be obtained from mkbootimg tools during unpack of your stock firmware bootimage. Read more about them <a href=https://source.android.com/docs/core/architecture/bootloader/boot-image-header#implementing-versioning>here</a>.</p><p>After setting the flags, we want our kernel source to get built; as per the LineageOS build system we can either build our kernel from source or use prebuilt binaries as per our convenience. Usage of a source built kernel looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_KERNEL_CONFIG</span> <span style=color:#728e00>:=</span> <span style=color:#95a5a6>#(Kernel Config name to be picked up as per architecture from kernel-source-path/arch/&lt;device-architecture&gt;/configs/)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_KERNEL_SOURCE</span> <span style=color:#728e00>:=</span> <span style=color:#95a5a6>#(Your kernel source path from root of Android source)</span>
</span></span></code></pre></div><p>After setting up your flags it should look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>:=</span> <span style=color:#434f54>console</span><span style=color:#728e00>=</span>ttyMSM0,115200,n8 androidboot.hardware<span style=color:#728e00>=</span>qcom
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> androidboot.console<span style=color:#728e00>=</span>ttyMSM0
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> msm_rtb.filter<span style=color:#728e00>=</span>0x237 ehci-hcd.park<span style=color:#728e00>=</span><span style=color:#8a7b52>3</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> lpm_levels.sleep_disabled<span style=color:#728e00>=</span><span style=color:#8a7b52>1</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> androidboot.bootdevice<span style=color:#728e00>=</span>7824900.sdhci
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> <span style=color:#434f54>earlycon</span><span style=color:#728e00>=</span>msm_serial_dm,0x78af000
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> firmware_class.path<span style=color:#728e00>=</span>/vendor/firmware_mnt/image
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> androidboot.usbconfigfs<span style=color:#728e00>=</span><span style=color:#728e00>true</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> loop.max_part<span style=color:#728e00>=</span><span style=color:#8a7b52>7</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> androidboot.selinux<span style=color:#728e00>=</span>permissive
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_BASE</span> <span style=color:#728e00>:=</span> 0x80000000
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_PAGESIZE</span> <span style=color:#728e00>:=</span>  <span style=color:#8a7b52>2048</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_IMAGE_NAME</span> <span style=color:#728e00>:=</span> Image.gz-dtb
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_TAGS_OFFSET</span> <span style=color:#728e00>:=</span> 0x00000100
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_RAMDISK_OFFSET</span> <span style=color:#728e00>:=</span> 0x01000000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_KERNEL_CONFIG</span> <span style=color:#728e00>:=</span> X01AD_defconfig
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_KERNEL_SOURCE</span> <span style=color:#728e00>:=</span> kernel/asus/X01AD
</span></span></code></pre></div><p>A configuration with prebuilt kernel should look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>:=</span> <span style=color:#434f54>console</span><span style=color:#728e00>=</span>ttyMSM0,115200,n8 androidboot.hardware<span style=color:#728e00>=</span>qcom
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> androidboot.console<span style=color:#728e00>=</span>ttyMSM0
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> msm_rtb.filter<span style=color:#728e00>=</span>0x237 ehci-hcd.park<span style=color:#728e00>=</span><span style=color:#8a7b52>3</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> lpm_levels.sleep_disabled<span style=color:#728e00>=</span><span style=color:#8a7b52>1</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> androidboot.bootdevice<span style=color:#728e00>=</span>7824900.sdhci
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> <span style=color:#434f54>earlycon</span><span style=color:#728e00>=</span>msm_serial_dm,0x78af000
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> firmware_class.path<span style=color:#728e00>=</span>/vendor/firmware_mnt/image
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> androidboot.usbconfigfs<span style=color:#728e00>=</span><span style=color:#728e00>true</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> loop.max_part<span style=color:#728e00>=</span><span style=color:#8a7b52>7</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_CMDLINE</span> <span style=color:#728e00>+=</span> androidboot.selinux<span style=color:#728e00>=</span>permissive
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_BASE</span> <span style=color:#728e00>:=</span> 0x80000000
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_PAGESIZE</span> <span style=color:#728e00>:=</span>  <span style=color:#8a7b52>2048</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_IMAGE_NAME</span> <span style=color:#728e00>:=</span> Image.gz-dtb
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_KERNEL_TAGS_OFFSET</span> <span style=color:#728e00>:=</span> 0x00000100
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_RAMDISK_OFFSET</span> <span style=color:#728e00>:=</span> 0x01000000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_PREBUILT_KERNEL</span> <span style=color:#728e00>:=</span> device/asus/X01AD-kernel/Image.gz-dtb
</span></span></code></pre></div><p>Source will pick up these offset flags for use in <code>mkboot</code> arguments, so there&rsquo;s no need to set them again in the <code>BoardConfig</code>.</p><h2 id=moving-on-to-partition-flags>Moving on to partition flags<a hidden class=anchor aria-hidden=true href=#moving-on-to-partition-flags>#</a></h2><p>Different devices have different partition sizes and names. I will using my QCOM device as a reference, but it might be different for your device.</p><p>Basically, a built Android OS flashable ZIP flashes over the boot, cache, recovery and system partitions.</p><p>After Android 8.0, a new partition named vendor was introduced (Project Treble).</p><p>#(Comment need to do something here and redirect over project treble)</p><p>After more Android releases more partitions were introduced, so as per Android 11 convention, the partition used by Android are <code>boot</code>, <code>cache</code>, <code>odm</code>, <code>product</code>, <code>recovery</code>, <code>system</code>, <code>system_ext</code>, <code>vendor</code>. These are basic names and may change (like <code>system_a</code>, <code>system_b</code> for A/B devices).</p><p>You can check path of your partitions using:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls -l /dev/block/bootdevice/by-name
</span></span></code></pre></div><p>This path works for most of generic devices and may change.</p><p>Now in order to obtain partition sizes</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>blockdev --getsize64 &lt;partition-path&gt;
</span></span></code></pre></div><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>blockdev --getsize64 /dev/block/bootdevice/by-name/system
</span></span></code></pre></div><p>This will give output of your partition sizes in bytes, you can directly set it as a flag variable so no need to convert the values.</p><p>For prebuilt vendor based device trees, you can just fetch partition sizes for <code>boot</code>, <code>cache</code>, <code>odm</code>, <code>product</code>, <code>recovery</code>, <code>system</code>, <code>system_ext</code>, and <code>userdata</code> (<code>/data</code>).</p><p>No need to worry if you do not have a certain partition – this list is tentative.</p><p>After obtaining the partition sizes to set them as flags you can do this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#d35400>BOARD_&lt;partition-name-in-capital&gt;IMAGE_PARTITION_SIZE </span><span style=color:#728e00>:</span>=
</span></span></code></pre></div><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>BOARD_SYSTEMIMAGE_PARTITION_SIZE</span> <span style=color:#728e00>:=</span> <span style=color:#8a7b52>4294967296</span>
</span></span></code></pre></div><p>After that you need to set partition filesystem type, this can be <code>f2fs</code>, <code>ext2</code>, <code>ext3</code>, <code>ext4</code>, and so on. You can find your partition filesystem type in your device <code>fstab</code> located in <code>/vendor/etc/fstab.qcom</code></p><p>To set partition file system type you can do this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#d35400>BOARD_&lt;partition-name-in-caps&gt;IMAGE_FILE_SYSTEM_TYPE </span><span style=color:#728e00>:</span>=
</span></span></code></pre></div><p>Setting file system time for partitions is not important as the Android build system will pick default types if you do not set them, but the partition <code>userdata</code> is an exception where it is absolutely necessary to defined the filesystem type and the flags for doing so are different, namely:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_USERIMAGES_USE_EXT4</span> <span style=color:#728e00>:=</span> <span style=color:#728e00>true</span>
</span></span><span style=display:flex><span><span style=color:#95a5a6># or
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>TARGET_USERIMAGES_USE_F2FS</span><span style=color:#728e00>:=</span> <span style=color:#728e00>true</span>
</span></span></code></pre></div><p>After setting up your partition flags and file system types, it should look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#95a5a6># Partitions - Boot
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>BOARD_BOOTIMAGE_PARTITION_SIZE</span> <span style=color:#728e00>:=</span> <span style=color:#8a7b52>67108864</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_FLASH_BLOCK_SIZE</span> <span style=color:#728e00>:=</span> <span style=color:#8a7b52>131072</span> <span style=color:#95a5a6># (BOARD_KERNEL_PAGESIZE * 64)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#95a5a6># Partitions - Cache
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>BOARD_CACHEIMAGE_PARTITION_SIZE</span> <span style=color:#728e00>:=</span> <span style=color:#8a7b52>367001600</span>
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE</span> <span style=color:#728e00>:=</span> ext4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#95a5a6># Partitions - Recovery
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>BOARD_RECOVERYIMAGE_PARTITION_SIZE</span> <span style=color:#728e00>:=</span> <span style=color:#8a7b52>67108864</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#95a5a6># Partitions - System
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>BOARD_SYSTEMIMAGE_PARTITION_SIZE</span> <span style=color:#728e00>:=</span> <span style=color:#8a7b52>4294967296</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#95a5a6># Partitions - Userdata
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>BOARD_USERDATAIMAGE_PARTITION_SIZE</span> <span style=color:#728e00>:=</span> <span style=color:#8a7b52>55423516160</span>
</span></span></code></pre></div><p><strong>Note: keep in mind that these are different as per devices.</strong></p><h2 id=moving-on-to-device-platform>Moving on to Device Platform<a hidden class=anchor aria-hidden=true href=#moving-on-to-device-platform>#</a></h2><p>It can be set this way:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_BOARD_PLATFORM</span> <span style=color:#728e00>:=</span> 
</span></span></code></pre></div><p>it can be <code>msm8937</code>, <code>msm8953</code>, <code>sdm660</code>, and so on. It is to be set according to your device. It is a CAF variable which is picked up by the LineageOS build system in order to build chipset specific HALs (We will learn about this later).</p><h2 id=moving-on-to-recovery-fstab>Moving on to Recovery fstab<a hidden class=anchor aria-hidden=true href=#moving-on-to-recovery-fstab>#</a></h2><p>Won&rsquo;t explain much about it since you can read it <a href=https://source.android.com/docs/core/ota/nonab/device_code#partition-map>here</a>.</p><p>So after reading the above thread, you can take your device <code>fstab</code> which can be found in <code>/vendor/etc/fstab.qcom</code> (<code>fstab.qcom</code> in my case, it can be anything else for other chipset devices, <code>fstab.qcom</code> is picked up by our bootloader) and set the flag pointing out it in device tree.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_RECOVERY_FSTAB</span> <span style=color:#728e00>:=</span> fstab-path-in-device-source/fstab.qcom
</span></span></code></pre></div><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>TARGET_RECOVERY_FSTAB</span> <span style=color:#728e00>:=</span> <span style=color:#728e00>$(</span>DEVICE_PATH<span style=color:#728e00>)</span>/rootdir/etc/fstab.qcom
</span></span></code></pre></div><h2 id=generating-vndk-snapshots>Generating VNDK Snapshots<a hidden class=anchor aria-hidden=true href=#generating-vndk-snapshots>#</a></h2><p>Vendor Native Development Kit, check it out in brief <a href=https://source.android.com/docs/core/architecture/vndk/snapshot-generate>here</a>.</p><p>You can set <code>BoardConfig</code> flags as read above and set the VNDK version as per your desired vendor.</p><p>As a default behaviour, source sets <code>BOARD_VNDK_VERSION := current</code>, here current implies vndk version of current android source (like <code>29</code> for Q, <code>30</code> for R).</p><p>Suppose you are trying to build Android Q for a vendor based on Android 9 – you can then set <code>PRODUCT_TARGET_VNDK_VERSION :=</code> value as per your vendor (28 for Pie).</p><p>You can also include additional VNDK snapshots for your vendor, like if you want Oreo vndk snapshots as well as Pie, you can set <code>PRODUCT_EXTRA_VNDK_VERSIONS :=</code> value as you desire.</p><h2 id=sepolicy--selinux>SEPolicy / SELinux<a hidden class=anchor aria-hidden=true href=#sepolicy--selinux>#</a></h2><p>Setting SEPolicy is not very important for prebuilt vendor based device trees as most of selinux rules are defined in vendor sepolicy.</p><p>You can read about SEPolicy <a href=https://source.android.com/security/selinux>here</a>.</p><p>Your device will proceed onto boot animation on SELinux due to the same reason as listed above, so you can just fixup the remaining denials by setting up SELinux on the system side.</p><p>This can be done by including QCOM sepolicy (Board specific since this guide is for QCOM boards).</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>BOARD_PLAT_PRIVATE_SEPOLICY_DIR</span> <span style=color:#728e00>+=</span> device/qcom/sepolicy/private
</span></span><span style=display:flex><span><span style=color:#434f54>BOARD_PLAT_PUBLIC_SEPOLICY_DIR</span> <span style=color:#728e00>+=</span> device/qcom/sepolicy/public
</span></span></code></pre></div><p>This is global and can be used by any device, <code>BOARD_PLAT</code> implies SEPolicy will be updated in system side.</p><p>Similarly <code>BOARD_PRODUCT</code> for product side.</p><ul><li>Calling out vendor <code>BoardConfig</code> <code>Makefile</code>
Include your vendor device makefile as:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#95a5a6># Inherit from the proprietary version
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#a61717>include</span> <span style=color:#a61717>vendor/device-implementer/device-name/BoardConfigVendor.mk</span>
</span></span></code></pre></div><p>Example:-</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#95a5a6># Inherit from the proprietary version
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#a61717>include</span> <span style=color:#a61717>vendor/asus/X01AD/BoardConfigVendor.mk</span>
</span></span></code></pre></div><p>We will learn more about vendor a bit later.</p><h2 id=starting-out-with-device-product>Starting out with device product<a hidden class=anchor aria-hidden=true href=#starting-out-with-device-product>#</a></h2><ul><li>Source calls device product which relatively calls other <code>Makefiles</code> present in the device tree.</li><li>By default when a product <code>Makefile</code> is called, it also includes the <code>BoardConfig</code> <code>Makefile</code>, so we don&rsquo;t need to include it.</li><li>A device product <code>Makefile</code> looks like <code>ROM-name_device-name.mk</code>, for example <code>lineage_X01AD.mk</code>. This can change accordingly for other ROMs.</li><li>In the device product <code>Makefile</code> you can configure if you want 64/32-bit apps to run on your system, whether your device will have telephony (radio in basic words) or if it is wifi-only, and so on. These <code>Makefiles</code> are found in <code>build/target/product</code> in the source directory.</li></ul><p>According to basic <code>Makefile</code> syntax rules we can call another <code>Makefile</code> by using <code>$(call inherit-product, &lt;makefile-path>)</code>.</p><p>In Android source, there is a variable which sets path for <code>build/target</code>, i.e <code>$(SRC_TARGET_DIR)</code>, So in order to call a <code>Makefile</code> from target product we can just use <code>$(SRC_TARGET_DIR)/product/&lt;makefile-name></code>.</p><p>You can read these <code>Makefiles</code> for more information.</p><ul><li>Device product <code>Makefile</code> is also used to call the ROM specific common <code>Makefile</code> (mainly ROM specific features). You can find these <code>Makefiles</code> in <code>vendor/ROM-name/config/</code> which will be <code>vendor/lineage/config</code> in our case.</li></ul><p>We can call it this way:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#728e00>$(</span><span style=color:#434f54>call</span> <span style=color:#434f54>inherit</span>-<span style=color:#434f54>product</span>, <span style=color:#434f54>vendor</span>/<span style=color:#434f54>lineage</span>/<span style=color:#434f54>config</span>/<span style=color:#434f54>common_full_phone</span>.<span style=color:#434f54>mk</span><span style=color:#728e00>)</span>
</span></span></code></pre></div><ul><li>In the end, we need to set device name and product name which should match our ROM-name.</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#95a5a6># Device identifiers.
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>PRODUCT_NAME</span> <span style=color:#728e00>:=</span> lineage_X01AD
</span></span><span style=display:flex><span><span style=color:#434f54>PRODUCT_DEVICE</span> <span style=color:#728e00>:=</span> X01AD
</span></span><span style=display:flex><span><span style=color:#434f54>PRODUCT_MANUFACTURER</span> <span style=color:#728e00>:=</span> asus
</span></span><span style=display:flex><span><span style=color:#434f54>PRODUCT_BRAND</span> <span style=color:#728e00>:=</span> asus
</span></span><span style=display:flex><span><span style=color:#434f54>PRODUCT_MODEL</span> <span style=color:#728e00>:=</span> ASUS_X01AD
</span></span></code></pre></div><p>These are basic device identifiers and I don&rsquo;t think further explanation is required since they&rsquo;re fairly self-explanatory.</p><h2 id=calling-our-device-product>Calling our device product<a hidden class=anchor aria-hidden=true href=#calling-our-device-product>#</a></h2><ul><li>Since Android Q, we need to create <code>AndroidProducts.mk</code> in order to call our device product makefile.</li></ul><p>This can be done this way:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>PRODUCT_MAKEFILES</span> <span style=color:#728e00>:=</span> <span style=color:#7f8c8d>\
</span></span></span><span style=display:flex><span><span style=color:#7f8c8d></span>    <span style=color:#728e00>$(</span>LOCAL_DIR<span style=color:#728e00>)</span>/ROM-name_device-name.mk
</span></span></code></pre></div><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>PRODUCT_MAKEFILES</span> <span style=color:#728e00>:=</span> <span style=color:#7f8c8d>\
</span></span></span><span style=display:flex><span><span style=color:#7f8c8d></span>    <span style=color:#728e00>$(</span>LOCAL_DIR<span style=color:#728e00>)</span>/lineage_X01AD.mk
</span></span></code></pre></div><p>You can find a reference commit to set device product <a href=https://github.com/danascape/android_device_asus_X01AD/commit/666612c5b81e514925ebed4b63954313e373804a>here</a>.</p><h2 id=last-but-not-the-least>Last but not the least<a hidden class=anchor aria-hidden=true href=#last-but-not-the-least>#</a></h2><ul><li>You need to call this <code>Makefile</code> from device product <code>Makefile</code>:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#728e00>$(</span><span style=color:#434f54>call</span> <span style=color:#434f54>inherit</span>-<span style=color:#434f54>product</span>, <span style=color:#434f54>device</span>/<span style=color:#434f54>device</span>-<span style=color:#434f54>implementer</span>/<span style=color:#434f54>device</span>-<span style=color:#434f54>name</span>/<span style=color:#434f54>device</span>.<span style=color:#434f54>mk</span><span style=color:#728e00>)</span>
</span></span></code></pre></div><p>Example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#95a5a6># Inherit from X01AD device
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#728e00>$(</span><span style=color:#434f54>call</span> <span style=color:#434f54>inherit</span>-<span style=color:#434f54>product</span>, <span style=color:#434f54>device</span>/<span style=color:#434f54>asus</span>/<span style=color:#434f54>X</span>01<span style=color:#434f54>AD</span>/<span style=color:#434f54>device</span>.<span style=color:#434f54>mk</span><span style=color:#728e00>)</span>
</span></span></code></pre></div><ul><li>We create a device makefile in our device tree which defines package names or device dimensions or screen density.</li></ul><p>Some basic flags are lister here:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#95a5a6># Boot animation
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>TARGET_SCREEN_HEIGHT</span> <span style=color:#728e00>:=</span>
</span></span><span style=display:flex><span><span style=color:#434f54>TARGET_SCREEN_WIDTH</span> <span style=color:#728e00>:=</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#95a5a6># Device uses high-density artwork where available
</span></span></span><span style=display:flex><span><span style=color:#95a5a6></span><span style=color:#434f54>PRODUCT_AAPT_CONFIG</span> <span style=color:#728e00>:=</span>
</span></span><span style=display:flex><span><span style=color:#434f54>PRODUCT_AAPT_PREF_CONFIG</span> <span style=color:#728e00>:=</span>
</span></span></code></pre></div><ul><li>You can also inherit your device proprietary system files (will explain a bit later) as follows:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#728e00>$(</span><span style=color:#434f54>call</span> <span style=color:#434f54>inherit</span>-<span style=color:#434f54>product</span>-<span style=color:#434f54>if</span>-<span style=color:#434f54>exists</span>, <span style=color:#434f54>vendor</span>/<span style=color:#434f54>device</span>-<span style=color:#434f54>implementer</span>/<span style=color:#434f54>device</span>-<span style=color:#434f54>name</span>/<span style=color:#434f54>device</span>-<span style=color:#434f54>name</span>-<span style=color:#434f54>vendor</span>.<span style=color:#434f54>mk</span><span style=color:#728e00>)</span>
</span></span></code></pre></div><h2 id=customizing-the-build-with-overlays>Customizing the build with overlays<a hidden class=anchor aria-hidden=true href=#customizing-the-build-with-overlays>#</a></h2><ul><li>Android build system uses overlays to customize or override resource values specifically for a product.</li><li>To use overlays, modify the project device <code>Makefile</code> to set <code>PRODUCT_PACKAGE_OVERLAYS</code> to a path relative to your top-level directory.</li></ul><p>You can do it as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#434f54>PRODUCT_PACKAGE_OVERLAYS</span> <span style=color:#728e00>:=</span> device/device-implementer/device-name/overlay
</span></span></code></pre></div><ul><li>Default overlays can be found by extracting frameworks-res from your stock device dump using <code>apktool</code> (not in scope of this guide).</li><li>Note that overlays are not important to boot the ROM on your device. They are used to overwrite certain properties or values over source to fixup certain bugs related to dimensions or similar.</li><li>Read more about overlays and how they work <a href=https://source.android.com/devices/architecture/rros>here</a>.</li></ul><h2 id=setting-up-device-vendor>Setting up device vendor<a hidden class=anchor aria-hidden=true href=#setting-up-device-vendor>#</a></h2><ul><li>There are certain libraries and APKs which are not source buildable (or proprietary) but are important for devices to have in order to gain some features or functionalities. These libraries or apps are listed in separate repo with proprietary files.</li><li>In order to generate this repository, we extract the required proprietary libraries or apps from stock OEM firmware using <em>proprietary extract scripts</em>. These scripts are present in ROM side in certain ROMs which can be picked up from basic scripts which we set in our device trees, and which define certain variables and helps in generating a <code>Makefile</code> to ease our work and just call the repo in order to get started.</li><li>At first you can pick these device-side shell scripts from <a href=https://github.com/danascape/device_asus_X01AD/commit/08b2897c33ed5cf7fd18198b30752f6>here</a> and modify them based on your device product name and manufacturer.</li><li>Before running your shell scripts create a proprietary files list as per your device called <code>proprietary-files.txt</code> this way:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span># ANT
</span></span><span style=display:flex><span>-lib/libantradio.so
</span></span><span style=display:flex><span>-lib64/libantradio.so
</span></span><span style=display:flex><span>product/lib/com.qualcomm.qti.ant@1.0.so
</span></span><span style=display:flex><span>product/lib64/com.qualcomm.qti.ant@1.0.so
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Alarm
</span></span><span style=display:flex><span>product/framework/vendor.qti.hardware.alarm-V1.0-java.jar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Audio
</span></span><span style=display:flex><span>etc/permissions/audiosphere.xml
</span></span><span style=display:flex><span>framework/audiosphere.jar
</span></span></code></pre></div><p>This is a section of my current proprietary list and it can be different for other devices. You can find my full system-side listing <a href=https://github.com/danascape/device_asus_X01AD/blob/lineage-17.1-preb/proprietary-files.txt>here</a>.</p><ul><li>Now, hoping that your list is created and all went well, in order to run <code>extract-files.sh</code>, you need <code>adb</code> support on your system or device dump where you can point out script to extract. You can read these scripts in order to check how they work and extract.</li><li>After you run these scripts, it will extract the apps and libs listed in your proprietary files and will setup makefiles in a separate directory which can be called as listed above in BoardConfig and device makefile section.</li></ul><h2 id=getting-things-running>Getting things running<a hidden class=anchor aria-hidden=true href=#getting-things-running>#</a></h2><ul><li>If all above goes well, you can go to your ROM source directory and <code>lunch</code> the device product (I will not explain how to start build as its a basic requirement to know how to build a ROM before you do a bringup).</li><li>Start your build and let it complete. These are only basic requirements for a device to get built and booting it is a different thing. Sometimes your ROM might get stuck on logo or stuck on endless boot animation, you will need to debug these issues in order to get things running.</li><li>I will list up some reference system-only device trees that you can learn from.</li></ul><p><a href=https://github.com/danascape/device_asus_X01AD/tree/lineage-17.1-preb>danascape/device_asus_X01AD</a></p><p><a href=https://github.com/danascape/device_oneplus_billie/tree/lineage-17.1-prebuilt>danascape/device_oneplus_billie</a></p><p><a href=https://github.com/danascape/device_xiaomi_olive/tree/lineage-17.1-preb>danascape/device_xiaomi_olive</a></p><p><a href=https://github.com/danascape/device_xiaomi_violet/tree/lineage-17.1-prebuilt>danascape/device_xiaomi_violet</a></p><ul><li>Certain device might need more things in order to get booting. These things might include AB or dynamic partition based BoardConfig flags, boot control HAL or gpt-utils or some extra libs. You can check more about how I did these things in above references.</li></ul><p>Let me know your new experiences at my <a href=mail:danascape@gmail.com>email</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://danascape.github.io/posts/3/><span class=title>« Prev</span><br><span>Introduction to AOSP</span>
</a><a class=next href=https://danascape.github.io/posts/1/><span class=title>Next »</span><br><span>Writing an Overlayed DTS</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://danascape.github.io/>Saalim Quadri</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>