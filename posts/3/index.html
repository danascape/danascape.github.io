<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introduction to AOSP | Saalim Quadri</title><meta name=keywords content><meta name=description content="The Android Open Source Project is an open source development project managed by Google, and anyone is welcome to evaluate and add code and fixes to the source code.

Android System Architecture
Let&rsquo;s first talk about the layers of an Android device&rsquo;s architecture before delving into the build system and the source code.


Application Layer:
This layer includes built-in/system applications for direct end-user interaction."><meta name=author content="squadri"><link rel=canonical href=https://danascape.github.io/posts/3/><link crossorigin=anonymous href=/assets/css/stylesheet.ecb14332dfba04052a266caa0f33168daa8dd2df45fe49adcb98d99df3cb40f6.css integrity="sha256-7LFDMt+6BAUqJmyqDzMWjaqN0t9F/kmty5jZnfPLQPY=" rel="preload stylesheet" as=style><link rel=icon href=https://danascape.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://danascape.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://danascape.github.io/favicon.ico><link rel=apple-touch-icon href=https://danascape.github.io/favicon.ico><link rel=mask-icon href=https://danascape.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://danascape.github.io/posts/3/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WDDV94BTDD"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WDDV94BTDD")}</script><meta property="og:url" content="https://danascape.github.io/posts/3/"><meta property="og:site_name" content="Saalim Quadri"><meta property="og:title" content="Introduction to AOSP"><meta property="og:description" content="The Android Open Source Project is an open source development project managed by Google, and anyone is welcome to evaluate and add code and fixes to the source code.
Android System Architecture Let’s first talk about the layers of an Android device’s architecture before delving into the build system and the source code.
Application Layer: This layer includes built-in/system applications for direct end-user interaction."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-06T00:00:00+05:30"><meta property="article:modified_time" content="2022-11-06T00:00:00+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduction to AOSP"><meta name=twitter:description content="The Android Open Source Project is an open source development project managed by Google, and anyone is welcome to evaluate and add code and fixes to the source code.

Android System Architecture
Let&rsquo;s first talk about the layers of an Android device&rsquo;s architecture before delving into the build system and the source code.


Application Layer:
This layer includes built-in/system applications for direct end-user interaction."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://danascape.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Introduction to AOSP","item":"https://danascape.github.io/posts/3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introduction to AOSP","name":"Introduction to AOSP","description":"The Android Open Source Project is an open source development project managed by Google, and anyone is welcome to evaluate and add code and fixes to the source code.\nAndroid System Architecture Let\u0026rsquo;s first talk about the layers of an Android device\u0026rsquo;s architecture before delving into the build system and the source code.\nApplication Layer: This layer includes built-in/system applications for direct end-user interaction.\n","keywords":[],"articleBody":"The Android Open Source Project is an open source development project managed by Google, and anyone is welcome to evaluate and add code and fixes to the source code.\nAndroid System Architecture Let’s first talk about the layers of an Android device’s architecture before delving into the build system and the source code.\nApplication Layer: This layer includes built-in/system applications for direct end-user interaction.\nApplication Framework: This layer comprises of libraries that are created and run in the background, and are made accessible by Android interfaces, giving developers the API they need to create application’s individual parts.\nSome libraries present in an application framework are: Activity Manager: Oversees the life-cycle of each application (activity). Location Manager: Includes positioning services and geographic layers. Package Manager: Responsible for application specific actions, involving installation, permissions, and so on. Resource Manager: Provides the application the different resources it needs, including translated strings, images, layout files, color files, and so on. Notification Manager: Allows the application to display personalised display prompt information in the status bar. Telephony Manager: Controls all the mobile device features features, including the radio and SIM. Windows Manager: Controls how windows operate, ensuring that each activity opens in a new window. Content Providers: Enables data sharing between different applications. View System: Creating crucial view elements for an application, such as inflating the layout and displaying views on the screen. System Runtime Layer (Native): This consists of 2 layers:\nC/C++ Libraries: They provide services through the applications framework. Runtime Libraries: Core Library: It provides most of the core library functions so that developers can use the language to write applications. Virtual Machines: Java Virtual Machine (JVM) is a virtual machine capable of executing Java bytecode regardless of the base platform. The Java bytecode can run on any machine capable of supporting JVM. The Java compiler converts .java files into class files (bytecode). The bytecode is passed to JVM, which compiles it into machine code for execution directly on the CPU. Dalvik Virtual Machine (DVM) is a Java virtual machine developed and written by Dan Bornstein and others as a part of the Android mobile platform. Dalvik is a runtime for Android Operating System components and user applications. It is a virtual machine optimised for Android devices. It optimises the virtual machine for memory, battery life and performance. It allows multiple instances of VM to run in limited memory simultaneously. Each application is executed as an independent Linux process. Hardware Abstraction Layer (HALs)\nIt is the interface between the Operating System Kernel and the hardware circuit to abstract or bring out the features of the hardware. It is used to control hardware using syscalls or proc values created by the kernel. It is generic and can be transplanted on various platforms. Linux Kernel\nCore system services depend or run on top of the Linux kernel. Android specific drivers are added on the base Linux kernel source for these core services. The system security, memory management, process management, network protocol stack and drivers models, etc. Android Boot Process The Boot ROM code starts executing from a pre-defined location which is hard-coded inside the ROM (chipset). It loads the bootloader into the RAM and starts executing. The bootloader runs in 2 stages: It detects the external RAM and loads programs which helps in executing the second stage. The bootloader sets up the network and memory, along with a basic environment to run the Linux kernel. The bootloader is able to provide configuration parameters or inputs to the kernel for its specific purpose. The Android Linux kernel is launched to set up cache and scheduling, loading of drivers, and so on. It then calls /init which is the root of the very first process. init is responsible for setting up kernel mounts like /sys, /dev and /proc. It then executes init.rc to proceed for further processing. Zygote is a virtual machine process that starts at system boot. It pre-loads and initializes core library classes, and enables code-sharing among the Dalvik VM. Zygote also launches system services. It forks new processes to launch the system services, some of which are: Power manager Activity Manager Telephony registry Package manager Content manager Zygote is also responsible for launching: Status bar services Hardware services Connectivity services Notification manager Corner System of Android Inter-Process Communication (IPC)\nIt is a framework for the exchange of signals and data across multiple processes. It is used for passing of messages, synchronisation, shared memory and Remote Procedure Calls (RPCs). It enables information sharing, computational speed-up, modularity, convenience, privilege separation, data isolation and stability. Processes in Android are isolated and have a separate address space. One process cannot directly access another process’ memory; however if a process wants to offer some useful services to another process in order to discover or interact with those services, IPC can be used. Why the Binder?\nThe existing IPC mechanisms were not reliable enough. Binder was a new IPC mechanism was introduced which abstracts the low-level details of IPC from the developer, allowing the applications to easily talk to both the system server and other remote service components. How was it implemented?\nAs discussed before, a process cannot access another process’ memory directly; however the kernel has control over all processes and can therefore expose an interface that enables IPC. The /dev/binder device created by the binder kernel drivers is the central object of the framework and all IPC calls go through it. The binder driver manages part of the address space of each process. The memory is real-only to the process, and all the writing is all done by the kernel. When a process sends a message to another process, the kernel allocates some space in the destination process memory and copies the message data directly from the sender process. It then queues a message to the receiving process telling it where the received message is. The recipient can then access that message directly which happens in its own memory space. Establishing a Build Environment To build AOSP, a Linux build machine is recommended, with the following minimal specifications: ~16-cores, 32GB of RAM and around 300GB of free disk space, as per the AOSP docs.\nTo setup the Linux build environment , you can directly run this command on your linux machine with elevated permissions:\ncurl https://raw.githubusercontent.com/akhilnarang/scripts/master/setup/android_build_env.sh | sudo sh Downloading the Source Code We are going to build a Generic System Image, that is common to all devices. You can read more about GSI here.\nYou can choose a source code of your choice. The base generic source code is uploaded by Google at android.googlesource.com.\nHowever, we also have LineageOS which is a fork of AOSP that also has generic image targets present (Credits to LineageOS developers).\nWe are going to use the `repo tool that was installed during the setup we did in order to sync the source code. Check out the LineageOS manifest here to find the branch that you need to sync. Currently the generic targets for GSI are available in lineage-18.1 (based on android 11) and above. repo init -u https://github.com/LineageOS/android -b lineage-18.1 repo sync This will start downloading the source code, and if all goes well you will be able to see the directory structure after a successful source checkout. Building the Source Code Since we are selecting a generic target to build, let’s move forward with building an arm64 GSI for AB-type partitioning.\nTo build the source code:\nFirst of all we have to setup the AOSP build environment: source build/envsetup.sh Then we have to lunch the required build target: lunch lineage_arm64_ab-userdebug Here lineage_arm64_ab is the product name and userdebug stands for user-debuggable. You can read more about the build types here. Now start the build by just running make This will start the build and will take a few hours to complete. The build time totally depends on your machine configuration – it can take upto few minutes to even a day! Emulating an Android Device After a successful build, the emulator path is added to the build path and can be run using the command:\nemulator After some time, you will be able to see a GUI interface that will boot the built images.\nWhat’s next? After the Operating System has booted, you can enjoy the appearance of pure AOSP.\nSome individuals could be unsure on what to do next. This is a normal question since it may have taken you some time to get here because utilising the AOSP build system is challenging and you may have made a common error. Once the OS has successfully booted, you can observe how a pure AOSP interface differs significantly from the UI on your Android smartphone. This is typical since Original Design Manufacturers (ODMs) use this source code as the starting point for later modifications to create the UI you adore on your smartphones. These ODMs improve the aesthetics of the AOSP framework, which handles UI management. These ODMs are also responsible for optimising the AOSP’s base components in order to provide a better user experience. The ODMs work on components that are used to specify the sort of device we are utilising as well as add hardware functionality support to the source code; these components are sometimes referred to as a device tree. The device configuration tree used by the AOSP build system contains board-specific changes like as partition sizes, feature flags, packages, configuration XMLs, properties, and so forth. These files are necessary for this generic source code to execute as reliably as or even more reliably than the device’s stock Operating System. Many of these files are already included in the source code and are produced by ODMs. These files allow us to create our own device tree, which we can then use to successfully build using the build system and boot the device. We also alter and employ these device trees in the creation of custom ROMs. You can try writing or finding the device tree of your own device that has an unlocked bootloader after becoming familiar with the AOSP build system. At this point, you will face challenges like working with and booting the device’s linux kernel or finding the configuration files that one requires. You can learn more about device trees and how to write one here. You can attempt delving into the XMLs inside the framework/base portion of the source code and studying them in order to adjust the layouts of the SystemUI or the QS tiles, the Notifications, and so on. If you are interested in the frontend/UI just like MIUI or OneUI do it. AOSP has its own XML-style layout, which will take some time getting accustomed to, but you will soon understand it and build on it as needed. There are other areas of the source code you can look into and learn more about, such the system libraries, core components, packages, and so forth (as mentioned in the architecture layers section). After gaining a basic idea of what AOSP is and how it functions, in addition to the cornerstone, which is the most crucial component of Android, you may start working your way through it. Let me know your experience with reading this blog at my email.\n","wordCount":"1867","inLanguage":"en","datePublished":"2022-11-06T00:00:00+05:30","dateModified":"2022-11-06T00:00:00+05:30","author":{"@type":"Person","name":"squadri"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://danascape.github.io/posts/3/"},"publisher":{"@type":"Organization","name":"Saalim Quadri","logo":{"@type":"ImageObject","url":"https://danascape.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://danascape.github.io/ accesskey=h title="squadri (Alt + H)"><img src=https://danascape.github.io/apple-touch-icon.png alt aria-label=logo height=35>squadri</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://danascape.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://danascape.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=https://danascape.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Introduction to AOSP</h1><div class=post-meta><span title='2022-11-06 00:00:00 +0530 IST'>November 6, 2022</span>&nbsp;·&nbsp;1867 words&nbsp;·&nbsp;squadri&nbsp;|&nbsp;<a href="mailto:saalim.priv@gmail.com?subject=/posts/3/index.md" rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>The Android Open Source Project is an open source development project managed by Google, and anyone is welcome to evaluate and add code and fixes to the source code.</p><p><img alt="Photo by Marek Piwnicki / Unsplash" loading=lazy src=/posts/3/img/intro_title.jpeg title="Photo by Marek Piwnicki / Unsplash"></p><h2 id=android-system-architecture>Android System Architecture<a hidden class=anchor aria-hidden=true href=#android-system-architecture>#</a></h2><p>Let&rsquo;s first talk about the layers of an Android device&rsquo;s architecture before delving into the build system and the source code.</p><ul><li><p><strong>Application Layer</strong>:
This layer includes built-in/system applications for direct end-user interaction.</p></li><li><p><strong>Application Framework</strong>:
This layer comprises of libraries that are created and run in the background, and are made accessible by Android interfaces, giving developers the API they need to create application&rsquo;s individual parts.</p><ul><li>Some libraries present in an application framework are:<ol><li><strong>Activity Manager</strong>: Oversees the life-cycle of each application (activity).</li><li><strong>Location Manager</strong>: Includes positioning services and geographic layers.</li><li><strong>Package Manager</strong>: Responsible for application specific actions, involving installation, permissions, and so on.</li><li><strong>Resource Manager</strong>: Provides the application the different resources it needs, including translated strings, images, layout files, color files, and so on.</li><li><strong>Notification Manager</strong>: Allows the application to display personalised display prompt information in the status bar.</li><li><strong>Telephony Manager</strong>: Controls all the mobile device features features, including the radio and SIM.</li><li><strong>Windows Manager</strong>: Controls how windows operate, ensuring that each activity opens in a new window.</li><li><strong>Content Providers</strong>: Enables data sharing between different applications.</li><li><strong>View System</strong>: Creating crucial view elements for an application, such as inflating the layout and displaying views on the screen.</li></ol></li></ul></li><li><p><strong>System Runtime Layer (Native)</strong>:
This consists of 2 layers:</p><ol><li><strong>C/C++ Libraries</strong>: They provide services through the applications framework.</li><li><strong>Runtime Libraries</strong>:<ul><li><strong>Core Library</strong>: It provides most of the core library functions so that developers can use the language to write applications.</li><li>Virtual Machines:<ul><li>Java Virtual Machine (JVM) is a virtual machine capable of executing Java bytecode regardless of the base platform. The Java bytecode can run on any machine capable of supporting JVM. The Java compiler converts .java files into class files (bytecode). The bytecode is passed to JVM, which compiles it into machine code for execution directly on the CPU.</li><li>Dalvik Virtual Machine (DVM) is a Java virtual machine developed and written by Dan Bornstein and others as a part of the Android mobile platform. Dalvik is a runtime for Android Operating System components and user applications.</li><li>It is a virtual machine optimised for Android devices. It optimises the virtual machine for memory, battery life and performance. It allows multiple instances of VM to run in limited memory simultaneously. Each application is executed as an independent Linux process.</li></ul></li></ul></li></ol></li><li><p><strong>Hardware Abstraction Layer (HALs)</strong></p><ul><li>It is the interface between the Operating System Kernel and the hardware circuit to abstract or bring out the features of the hardware.</li><li>It is used to control hardware using syscalls or proc values created by the kernel.</li><li>It is generic and can be transplanted on various platforms.</li></ul></li><li><p><strong>Linux Kernel</strong></p><ul><li>Core system services depend or run on top of the Linux kernel. Android specific drivers are added on the base Linux kernel source for these core services.</li><li>The system security, memory management, process management, network protocol stack and drivers models, etc.</li></ul></li></ul><h2 id=android-boot-process>Android Boot Process<a hidden class=anchor aria-hidden=true href=#android-boot-process>#</a></h2><p><img loading=lazy src=/posts/3/img/boot_process.png></p><ul><li>The Boot ROM code starts executing from a pre-defined location which is hard-coded inside the ROM (chipset). It loads the bootloader into the RAM and starts executing.</li><li>The bootloader runs in 2 stages:<ol><li>It detects the external RAM and loads programs which helps in executing the second stage.</li><li>The bootloader sets up the network and memory, along with a basic environment to run the Linux kernel.</li><li>The bootloader is able to provide configuration parameters or inputs to the kernel for its specific purpose.</li></ol></li><li>The Android Linux kernel is launched to set up cache and scheduling, loading of drivers, and so on. It then calls <code>/init</code> which is the root of the very first process.</li><li><code>init</code> is responsible for setting up kernel mounts like <code>/sys</code>, <code>/dev</code> and <code>/proc</code>. It then executes <code>init.rc</code> to proceed for further processing.</li><li>Zygote is a virtual machine process that starts at system boot. It pre-loads and initializes core library classes, and enables code-sharing among the Dalvik VM.</li><li>Zygote also launches system services. It forks new processes to launch the system services, some of which are:<ol><li>Power manager</li><li>Activity Manager</li><li>Telephony registry</li><li>Package manager</li><li>Content manager</li></ol></li><li>Zygote is also responsible for launching:<ol><li>Status bar services</li><li>Hardware services</li><li>Connectivity services</li><li>Notification manager</li></ol></li></ul><h2 id=corner-system-of-android>Corner System of Android<a hidden class=anchor aria-hidden=true href=#corner-system-of-android>#</a></h2><ul><li><p><strong>Inter-Process Communication (IPC)</strong></p><ul><li>It is a framework for the exchange of signals and data across multiple processes. It is used for passing of messages, synchronisation, shared memory and Remote Procedure Calls (RPCs).</li><li>It enables information sharing, computational speed-up, modularity, convenience, privilege separation, data isolation and stability.</li><li>Processes in Android are isolated and have a separate address space. One process cannot directly access another process&rsquo; memory; however if a process wants to offer some useful services to another process in order to discover or interact with those services, IPC can be used.</li></ul></li><li><p><strong>Why the Binder?</strong></p><ul><li>The existing IPC mechanisms were not reliable enough.
Binder was a new IPC mechanism was introduced which abstracts the low-level details of IPC from the developer, allowing the applications to easily talk to both the system server and other remote service components.</li></ul></li><li><p><strong>How was it implemented?</strong></p><ul><li>As discussed before, a process cannot access another process&rsquo; memory directly; however the kernel has control over all processes and can therefore expose an interface that enables IPC.</li><li>The /dev/binder device created by the binder kernel drivers is the central object of the framework and all IPC calls go through it.</li><li>The binder driver manages part of the address space of each process. The memory is real-only to the process, and all the writing is all done by the kernel.</li><li>When a process sends a message to another process, the kernel allocates some space in the destination process memory and copies the message data directly from the sender process.</li><li>It then queues a message to the receiving process telling it where the received message is. The recipient can then access that message directly which happens in its own memory space.</li></ul></li></ul><h2 id=establishing-a-build-environment>Establishing a Build Environment<a hidden class=anchor aria-hidden=true href=#establishing-a-build-environment>#</a></h2><p>To build AOSP, a Linux build machine is recommended, with the following minimal specifications: ~16-cores, 32GB of RAM and around 300GB of free disk space, as per the <a href=https://source.android.com/docs/setup/start/initializing>AOSP docs</a>.</p><p>To setup the Linux build environment , you can directly run this command on your linux machine with elevated permissions:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl https://raw.githubusercontent.com/akhilnarang/scripts/master/setup/android_build_env.sh | sudo sh
</span></span></code></pre></div><h2 id=downloading-the-source-code>Downloading the Source Code<a hidden class=anchor aria-hidden=true href=#downloading-the-source-code>#</a></h2><p>We are going to build a Generic System Image, that is common to all devices. You can read more about GSI <a href=https://source.android.com/docs/setup/create/gsi>here</a>.</p><p>You can choose a source code of your choice. The base generic source code is uploaded by Google at <a href=https://android.googlesource.com/>android.googlesource.com</a>.</p><p>However, we also have LineageOS which is a fork of AOSP that also has generic image targets present (<em>Credits to LineageOS developers</em>).</p><ul><li>We are going to use the `repo tool that was installed during the setup we did in order to sync the source code.</li><li>Check out the LineageOS manifest <a href=https://github.com/LineageOS/android>here</a> to find the branch that you need to sync. Currently the generic targets for GSI are available in lineage-18.1 (based on android 11) and above.</li><li><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>      repo init -u https://github.com/LineageOS/android -b lineage-18.1
</span></span></code></pre></div></li><li><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>      repo sync
</span></span></code></pre></div></li><li>This will start downloading the source code, and if all goes well you will be able to see the directory structure after a successful source checkout.</li></ul><h2 id=building-the-source-code>Building the Source Code<a hidden class=anchor aria-hidden=true href=#building-the-source-code>#</a></h2><p>Since we are selecting a generic target to build, let&rsquo;s move forward with building an <code>arm64</code> GSI for AB-type partitioning.</p><p>To build the source code:</p><ol><li>First of all we have to setup the AOSP build environment:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#728e00>source</span> build/envsetup.sh
</span></span></code></pre></div><ol start=2><li>Then we have to lunch the required build target:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>    lunch lineage_arm64_ab-userdebug
</span></span></code></pre></div><p>Here <code>lineage_arm64_ab</code> is the product name and <code>userdebug</code> stands for user-debuggable. You can read more about the build types <a href=https://source.android.com/docs/setup/build/building#choose-a-target>here</a>.
<img loading=lazy src=/posts/3/img/lunch_cmd.png></p><ol start=3><li>Now start the build by just running <code>make</code>
<img loading=lazy src=/posts/3/img/lunch_soong.png>
This will start the build and will take a few hours to complete. The build time totally depends on your machine configuration – it can take upto few minutes to even a <strong>day!</strong></li></ol><h2 id=emulating-an-android-device>Emulating an Android Device<a hidden class=anchor aria-hidden=true href=#emulating-an-android-device>#</a></h2><p>After a successful build, the emulator path is added to the build path and can be run using the command:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>emulator
</span></span></code></pre></div><p>After some time, you will be able to see a GUI interface that will boot the built images.</p><h2 id=whats-next>What&rsquo;s next?<a hidden class=anchor aria-hidden=true href=#whats-next>#</a></h2><p>After the Operating System has booted, you can enjoy the appearance of pure AOSP.</p><ul><li>Some individuals could be unsure on what to do next. This is a normal question since it may have taken you some time to get here because utilising the AOSP build system is challenging and you may have made a common error. Once the OS has successfully booted, you can observe how a pure AOSP interface differs significantly from the UI on your Android smartphone.</li><li>This is typical since Original Design Manufacturers (ODMs) use this source code as the starting point for later modifications to create the UI you adore on your smartphones.</li><li>These ODMs improve the aesthetics of the AOSP framework, which handles UI management. These ODMs are also responsible for optimising the AOSP&rsquo;s base components in order to provide a better user experience. The ODMs work on components that are used to specify the sort of device we are utilising as well as add hardware functionality support to the source code; these components are sometimes referred to as a device tree.</li><li>The device configuration tree used by the AOSP build system contains board-specific changes like as partition sizes, feature flags, packages, configuration XMLs, properties, and so forth. These files are necessary for this generic source code to execute as reliably as or even more reliably than the device&rsquo;s stock Operating System. Many of these files are already included in the source code and are produced by ODMs. These files allow us to create our own device tree, which we can then use to successfully build using the build system and boot the device.</li><li>We also alter and employ these device trees in the creation of custom ROMs.</li><li>You can try writing or finding the device tree of your own device that has an unlocked bootloader after becoming familiar with the AOSP build system. At this point, you will face challenges like working with and booting the device&rsquo;s linux kernel or finding the configuration files that one requires. You can learn more about device trees and how to write one <a href=https://blog.realogs.in/android-device-tree-bringup/>here</a>.</li><li>You can attempt delving into the XMLs inside the framework/base portion of the source code and studying them in order to adjust the layouts of the SystemUI or the QS tiles, the Notifications, and so on. If you are interested in the frontend/UI just like MIUI or OneUI do it. AOSP has its own XML-style layout, which will take some time getting accustomed to, but you will soon understand it and build on it as needed.</li><li>There are other areas of the source code you can look into and learn more about, such the system libraries, core components, packages, and so forth (as mentioned in the architecture layers section).</li><li>After gaining a basic idea of what AOSP is and how it functions, in addition to the cornerstone, which is the most crucial component of Android, you may start working your way through it.</li></ul><p>Let me know your experience with reading this blog at my <a href=mail:danascape@gmail.com>email</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://danascape.github.io/posts/4/><span class=title>« Prev</span><br><span>LFX Mentorship for Linux Kernel Bug Fixing</span>
</a><a class=next href=https://danascape.github.io/posts/2/><span class=title>Next »</span><br><span>Android Device Tree Bringup</span></a></nav></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//squadri.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://danascape.github.io/>Saalim Quadri</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>